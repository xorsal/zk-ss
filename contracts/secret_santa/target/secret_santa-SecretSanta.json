{"noir_version":"1.0.0-beta.14+82ec52a8c755d30ce655a2005834186a4acfa0c7-aztec","name":"SecretSanta","functions":[{"name":"advance_state","hash":"5034731447300234158","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"1643290557656260443":{"error_kind":"string","string":"Only admin"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15660711043745905308":{"error_kind":"string","string":"Already complete"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/71WzWoUQRCunumeXROMP6h4HCEHBQ/GeFEJKnFEPERRUEFEhkwbFvLH7BrizfgEilcFH0IkOeSYXAIhp0ByCbkFcskhueSU7WxXqNT2bmYmbAqW6umu+uqr6pqaFdCQ81bHyVQ8Pqw/VWtxTZsNYQ8kFBTRLsIzu1m22iNOfv0XQrYYZRYsn/+3qMwBc/nDob+AovEb+RufgvlDgESIP+WCuKX6r5use1j8gvyj0/K/3IYz3s0gORPZsX30f0o2Q6vvJEPpZt/fW7Ovov8zM+8/3uzfev51bvLn4Ober536eRc06nTP2pvaXbTreGrs5eTwRKKfJEmqq1VB8Hku7SQPppcD8zrHHPoyOlr5XNFpNF2p1pqwfQc2rj1w58Z5UTsqrv4yEkImEZJxvGq1uZsHLAblEEI2fFOvK/bhqF5vahNpPKJf6zjJUiv+3O6+TLwLTfH0eKLToleONjioFTSXA18Bz54ph58R3+4F5Fw5YimGFzh4u0aDkRCyiWDY0sGZ4ktmf4PxKBGfPCPqEvEDhsU5KGhuE8X4oW2v1QZrgHEt0MreWbcy9opqgSmIDb0v5cCgfpJhCHD3N/Uzgp8JyexvW23q/NiuXWMpx6dFcE7g4OTCx9yDFvaS5YD2fSQHzNN3xKB8TD/guOT98C6tNP7lUeGzvtXsbzXrzTezTBIAyPuyTUcYA4ui4PglA8OXzP6+1edIfNQyA4/1hb3Vfy/ujvGX3gjm3XUK/CB+OND9Z76/U/jXlnt7Hq1vfOgU/tpbNZt83//dKfyV0vbu0uLIj5PwDwBohCNUvwwAAA==","debug_symbols":"tZfRjuIwDEX/pc88JHZiJ/wKQqhAGVWqCurASivEv687JGm7UjIrhp0HbqHTg31z3dB7dWz2t49d25/On9V6c6/2Q9t17ceuOx/qa3vu5dN7pcYXbau1WVWaqjWLcLXWStSJalH/VFBBtSiJQlAU9aKmWsN43gal8DkHFR6gqH8qqqA6KAQVHkg5aILaoMID4SAHFR7K96B/qlFBhYcgCkExqPBQ+MYGpaAc1AUdeeKDFZ5Rj8eqio7trkPTjIbNLBRjL/XQ9Ndq3d+6blX9qrvb1z99Xur+S6/1IGfF0aY/igrw1HbNePRYTVer/KVagXLhcjn2LiG0sguILkDAcGQA8QwBCwQUEE6xjgyn3NQKuQUD8wwEa31gyDHbHKPUCo55eJaBxmRbsW9ohf5zK+AwtaLyq+LyCHYcEezB54rwhUaQLMRGkPyPGzH5RgoxB7ZxSYBpasQuB0VDqZM0KCh/UxWOl4xSQpXHBFHeZh3VpgSByVIZWZ2FFEKKllSCWMLsuhRNZZtM9Zg1lQtL60GnW4cHyMfDlYaFgNKwkMkbUq7EqKkSDzkIFBxBEw0xciOcDHnFUacg5ygUYsqUJpanCsxLk+KUzZVQIjhjEmG2G/zdhP35rAG9YdaA3zBr4N4wa9+0A7N22GQ3yMLSuBQv56dtCenf0+FcnDQxQ72SDk8TgfklgkkJ9ZRNKJZuoc7FWUevKJsvLGUUkBMEsPCLpbCqzHFUZKvNLsg3ZSBOZdhsuLCUUM069aKZsjHH0lZvWesUc7bLO+hW3tWHdlg8IzxG2tDW+64Jb0+3/jA7e/19iWfiM8ZlOB+a421oRtLsQUNeNzKrlrfyXCG/0zfEK/Lbx/jVfwA=","expression_width":{"Bounded":{"width":4}}},{"name":"constructor","hash":"910317684795147793","is_unconstrained":true,"custom_attributes":["external","initializer","public"],"abi":{"parameters":[{"name":"admin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"disclose_receiver","hash":"13806016383969401720","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"sender_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"receiver_nullifier","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"7182175156193537826":{"error_kind":"string","string":"Wrong state"},"12000676934365261133":{"error_kind":"string","string":"Already disclosed"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"13797760336213010086":{"error_kind":"string","string":"Already assigned"},"14189827170432234740":{"error_kind":"string","string":"Cannot choose yourself"},"14716172601447261746":{"error_kind":"string","string":"Invalid index"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tZ3drh61zsfvZR33IF92HG4FIVSgbFWqCuqmr/QK9d537MT/rFZ6QnhmekJ+rK6xYzue2JNU/fvlt3e/fP7Pz+8//v7Hf19++PHvl18+vf/w4f1/fv7wx69v/3r/x8f+079fgv4ntpcfypuX1P+n9iG+/BBDH1MfYx/zHMscqY/669xH7mOdo8yftzHmLi5KH+Mc0xzzHMscu7yU+8hz7PIS9VHm2MZYurzU9ZQ4xzTHLi/350qZI82R51jnKHNsY6QwxzjHNMcpj6Y8UnndHuI51jnKHNsYOcwxzjHNMc+xzHHK4ymPpzye8ljlpTcvNcwxzjHNMc+xzJHmyHOsc5Q5Tnky5cmUJ/r73X9S5yhzbGNsYY5xjmmOeY5ljjTHKa+pvL6OmsyxjTGG4KBPNoX+qyUoiEObEINDdEgOfQIlKRQHcmCH6iAObYIu8wEqOSskh+xQHMiBHVRyURCHNkFX/AAVSArZoTioQFZgh+ogE8r0dCzZoTiQAztUh+nvWNzh5A63JW5A0/PkDid3OLvD2R3O7nBdwQPc4ewOZ3c4u8PZHc7u8OoO15U8wB1e3eHVHV7d4dUdrut5gDu8usPFHa5reoAKFAUVqJYKObBDnaArnKJCf4p0YrqmB5ADO1QHcejTIHtvBofokByyQ3EgB3ZQyfrC1SwY0CZoFgxQyaSQHFSyKBQHcmCHLpmzQpfM9lSboFkwoEtmfX1rFgzIDl1y1Te+ZsGALrmqQM2CAeLQJVc1R7NgQHTokqvOR9NB9Jc1HQaQAztUB3FoE3QHGBAdkoNL1kwRVaqZMoAdqoM4tAmaKQOiQ3LIDi6ZXDK5ZN0SJCmIQ5ugaTUgOiSH7FAcyIEdXDK7ZM0dsW03OxQHcmCH6iAObYLmzoDo4JI1iUQrAU2iAeTAEzR3pCn0X266RDV3BpADO1QHcejTaEmLhOAQHZJDdigO5MAOKlmLBs2dAW2C5s6A6JAcVLKWKJo7A8iBHVSglh+aMgaaMgNUICskh+xQHKbncxKH6fmcg0N0SA7T8zkXB3KYns9lej6X6flcigM5sEN1EAf3PLnnyT1P7nlyz5N7ntzz5J4n9zy558k9z+55ds+ze57d8+yeZ/c8u+d1qTctDHUHaWqp7iADokNy0Go0RCWtP4NOTdf4IF3kkyIogTJIa9GgyoVADKogATWnFkARZDrU3S2DCohApsOK3AoyHWp/a5NKCKAIsvpcC9pgFXpRKiACMUh1pKgkoOak+TIpghIogwqIQAyCjmg6klJzSgEUQQmUQQVEIAZVEHQk6MjQYZ1HCkoJlEEFRCAGVZCAmlMJIOgo0FFMinq8VJCAmhMFUAQlUAYVEIGgg0yHNkgkoObEAWRSqpI9oWuIBdScagBFUALprLJaqdvOJAIxqIIE1JwsLwepjqzrxfJyUAYVEIEYZDo00paXg5qT5eUgk2ytXwYVkElWT1o2DqogmUTBY0QhgTKogAjEII8RBQF5jCgGkMeIoseIooA8RpQCKIISyGNEqYAIxKAKEpDHiHIAeYwoJ1AGFRCBGOQxoiwgjxGVADLJrGSS1QelgAjEIJPStEHXZ7VBIcuZQQVEIAZVkH210BlYzhhZzgyKoATKoAIikM1Po2BZNkhAzcmyTNsasiwbZDrUB5ZlgwqIQKpDGxeyLNNmhCzLBjUnyzJSD1mWDUqgDCogAjGoggTUnBp02O7H6lPLt0EZVEAEYlAFCahNYtv9BkVQAmWQ2SFKBGJQBQmoOVkODoqgBMog6IjQYRnKSak5WYYOiqAEyqACIhCDKgg6LEO1q2PL0EERlEAmhZTsCdZPUAEUQQmUQQVks1IrLfMGVZCAmpPtaoMiKIFMR1MqIAIxqIIEpDqqRtoydFAEJZBK1n6VLS8HMUglV/Wk5eWg5mR5OQgxqohRRYwqYlQRo4oYVcRIECNBjAQxEsRIEKOGGDXEqCFGDTFqiFFDjBpi1BCjhhg1j1ENARRBCeQxqqGACMSgChKQx6jGAIqgBLIYFSWLESkxqILEyfKoViV7VmdqOTOIQRUkoOY0vkrrDMZ3aaMEyqACIhCDKsh0sFJzsiwbFEGmIyplkOlQH1iWDWJQBakObfmqZZn2l9WybFAEJVAGFRCBGFRBAoIOy7KmHrcsG5RAGVRABGJQBQmoOVXoqNBRocNyUHvuajk4iEAMqiABNSfLwUERlEDQIdBhe572l9X2vEHNyTJ0UAQlUAYVEIEYBB2aoUn7waoZaiSaoZMiSE9Kgn3KtyeyUnOKARRBCZRBRYmUCMSgChJQc0oBFEGmQw8OUgYVEIEYVEGmoyo1pxxAEWSSRamACGSSm1IFCag5FY+RlAwqIAIxqII8RlIQI0KMCDEixIgQI0KMGDFixIgRI0aMGDFixIgRI0aMGDFixKgiRhUxqohRRYwqYlQRo4oYVcSoIkYVMRLESBAjzaOkB4SiedQ/VCsRiEHVSfMo6ZcJafaszrQVEIEYVEEC0llFPWiynBkUQQmUQQVEIAaZjqwkoOZkWTbIdIhSAqkO/frRLMsGEYhBqiPZ4Zo4JfdGs9walEAZZJJ1psm90ZKAmpPlkfaDzfJoUALZTJtSwRMEYhB0ZOjI0GFnsoMiKIEyCDoKJI88SnqAGEARlEAqRfvQRjzzo1EFCUjlac/ZLMsGRZDK006zIcvayDIjAkEHQwdDB3smtxpAEZRA0FEheeSRzqDCcoHlAsslub2CZwWzEsxKd6Zhm8DyBstbdHsbZtUwqwbLG3Q06GjQ0WB5c8v7h8uwMC5MC8vCOou2jrKwAUeVONCmbI9Fr/A60kJeqFPUzzIdZWEDWjZlMox4zDqwiXnh0paWtrS0oaTsKAsb0KrKiUtbXirQjHWsC2VhA1pS2ZFuQEfWsSykhXZpYhyq14Wy0Fxic6CAxyguTAuXNlraaGkb7dnAulAWNiAvbbxUWIE4zOTlEl4u4eUSS7bhh7ok1DXJuiZpaTYsrssldbnEsm/4oa5JypqkLJfI0iZLmyxtslwiyyWyXCLLJbK0taVifH60OxDj++NAXlgX2tQVo3Vr835EWpgXaupNpIW8UF1SoqGsxxrQEnLi0haXtri0xbKQFvLCunBpS0vF+ORfDctCWsgLbep2lyP798+OcWFaqK86uzVgVy8caaG5pBjW9ZgsbMCytJWlrSxtlqYTy0JayAuXtrJUjM/+ZiYtl9ByCS2X2DY4770sCbwmyWuStu0Ni3m5hJdLbOcbfuA1SV6T5OUSXtrq0laXtrpcUpdL6nJJXS6pS1tdKsYxnS3PcU43MC8sC23qZOhnfx0bsIWFurfY5Zpo++HEvNBcYv4dx3PjMV5YFy5tDdpSCAvjwrQwLywLaSFU2MUP7fij3fyYlEAZZNMWw3nUG+22x6TmZPuh3XqxGx+OaaH6gsbvFjxFIAZBT4KeBD2amZMiKIEyCDoyJNtFD5tMgfkF5heYb3XlMLrg4YJpFUzLNr9hHi37adlvVeYwmjA1wtQI5hP0EPQQ9BDMZ5jPMJ9hPkMHQ7Lml11CSppeg2oARZBNdaBfTrKLHpMqyO5NDmxAqzQnqv1kd9k0x+YPM6iAoEegR6BHBNSc7EbVoAiCDtyusgshtqPZjZBJbZLdCZlkUx1368q8hGa3QCYxyC6N2gU769omNqD1bWTX7HCjMONKod0ImQQ9EXoi9MQKEpBfobMbIpOgI0GyptAwK1WQgGC+NW7D6IyHM6aVMS3bw4Z5edmfl/3j6qwZXTC1gqkVmF+gp0BPgZ4C8wvMLzC/wHyCDjLJX768efHbxj//9endO71s/Or68Y9/v/z59tO7j3+9/PDx84cPb17+7+2Hz/ZL//3z7Ucb/3r7qf9pl/nu42997AJ/f//hndKXN+vp8PhR7QRkPq4lu0BEL5C+EhI3QmxnGDIS11ci0lci0kaEBD19GDL697tlCstXMvJjGbmHtU0ZnSs9krEzJeuB9JhGD/ZDU+gGU/g7m5L0xt80JTyOijwW0T/0uoj+Bbc9mkTbGJJZX2nDkNyPYq4aUh4bslnmWbRnGrPoX+Iggr5OlLhboc2+f41p9C9Pjy3ZLlHWj1kzrv2U8aGQ/UxKWDNp6aGQzSrNxR1Ses4uhzzl0VdT+NajdbO6GIurrhmU86C26HmW+2e6h1PYLk+8/fpmstZFlPr1m2s3jdAyhPR29WGapLgTklae9Pfww4WRNgsjEwcIIc4Pl+g/mJNemVPLQyHlsRCpvjj6V2wIyPxcbIkfxXYroXmSlP7B7JGEtFmgnKtnPJf06sVTv1kdm1doJM/33ussT/St5SsJmzXaTzo9Hv0Ic8W0l11f74w7Z2Bxlbic2TuUryVsFmjvlTwgvVlqj2Vs1icl39Moh+ckNAQk0nN2JPFJ9GYsPZax2+Ep4f1LrzakfyeDG2RIe05GDpDRS+XHMnZbfPGV0c/Wn5LQsJP004anJOiHZ9Sg/DiuZRPXUtjXZymvy9j2L9xZVu1HT4Y1Y4V2lKdk3GGK3Uwc04hFnsuUGvHqqpt8LfX7yugf3mALV3lORkUhG2t7nPUUrmbKTsJZplC4nimULy+vrTvbevH0UvjhNLabK6FWYXpVNH27udKmTeKafR59dcVXncE37tgtUYnYECTzwxLwtNR41SZ9U2rQDYUo31GI8h2FKN9RiPIdhShvClFGz8Y5PVeIol4o/fDyiUK09PMwFF8xPJLA9YbVIXesjnbD6qjhjtUhN6yOuuuks2DHL+GpRqWEGlZ00zPrI3KBhMeddKXrjUrl3WcrxitdHjYqdbNKCzePSKkxvvJmOJ/FUbtUb2iX5HK7JDe0S3K5XZLL7ZLc0C7JDe2S3NAuyQ3tklxul+RyuyQ3tEvterskN7RLckO7JPR9TTlsl+SGdqnV7yvjtF1qN7RL9rd0r6XKVsRZrmxFnCZLDNdbpnZDy7Td5g9bphhu6Jli+L5N0+uyJ8WHhXUMN3RNMd7RNsV4R98U4x2N086xGUeHpb9en6lIC1K3r/zHByvxhpI0xsvVYNweMh2WgzHK1Xow7k6aTgvCuDubOasI9yKOSsK9KYc1YUz5elH4D0LOqsK9kMOyMCa+vNntRBxudjsRx5vd7rzpcLP7B5+e1Yb/IOSsONwKucWaw/JwnzWHtV3cfde/RchphbgXcloiXj98itdPn+Idx0/xhvOnvU8Pa8T9xntaJJZyQ5FY6PsWia8rkc29nXLDx9NY7vh6Gssdn08j3fH99NSxr25l/YsikZK/nQuVh4cecXcUdVwkUrlcJBLdUCTuDqMOi8TtWdRpkUhyuUjcijgrEremnBaJu8Oo4yJxL+SwSNwKOS0Sd4dRh9vdTsThdrcTcbzd7U6kTre7vU8Pi8S9kMMikeN3tua0SKQbPgDGmr+zkOMicSvktEis11urer21qne0VvWG1mrr09MicbvxnhaJu9Ol4yJR8vctEl9XIvy4EtmdAGQRX+65hcfTsFPSh0JSzr7eO9PjK+Kyq1djjZhLX5OPi0TZfrKq6wYt9armmSKR1t0Hjo+r7xZuKPFavFzitXRDidfy5RKvlRtKvEaXS7ytiLMSb2vKaYnX5IYSby/ksMTbCjks8VKIVzerrYizzWor4nSzSqFc36z2Pj0s8fZCDku8nZBbrDkt8bZZc1idpd2Z1S1CTku8vZDDEi/t/lrUYdbsRBxmzU7EcdbsjqwO19nep6cl3nbjPSzx0u6j9WmJl3ZHTreUeK8qkcc3bNP2b0cdlngp5RtKvLT761HHJV5KdEOJt0+c4C/Xlp7NPfaV1ipdTt+diO2+eWbIVsSZIYe7d6Unu9UjQ/Yijgw57Zl3IrYfq84M2Yo4M+Twk9lOxPaQ6cyQrYgzQw6PunYi0vWlla4vrXR9aW1vhp0ZshVxZsjh/bSNCLm8suTywpLL64ouR4MuB4Mux+J6ll9P8idz/Kf+v29/ff/pq3+h8IuK+vT+7S8f3s3//f3zx19f/elf//+n/4n/C4d/fvrj13e/ff70TiWtf+aw/+fHmPtH//4Sqj+9eYnjB/3crP806A/i+I2iP+CfvuiU/gc=","expression_width":{"Bounded":{"width":4}}},{"name":"get_admin","hash":"17473078264236010876","is_unconstrained":true,"custom_attributes":["external","view","public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"9345055721478160917":{"error_kind":"string","string":"Function get_admin can only be called statically"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7VUO07DQBCddUxwPkiAiECiMRISPZSIAhEXUASJHACtYhNZsgmyDUoJ94ALUFHQUnIFCk5BQ48Xj8Ow8WdtxJNWM177vZm3HzNI0MI4dqJzbvvupXhgOKnDbzAoASuYm6u0gxMGRo0QGvEwQQnMkApV499ahixYiQ/ffAZ16yf+Baemf2hi7BM+7SXVXYxHl+RLmHcL+H/srW8QTg0+W82pL9CGxMcmPnfisYw5v/FPr0YT2zm07cAJQ3ow5fUpQhVNrYLmhqw5uPY898J1AmvqhtGcdiNDO801yPYm90W/o8g6vwImKIHpUo9rGMXebGEuPPcwn3k+DocRj9zREfc8lcXMW1hd4qyTBrYxl00KmKAE1iGmZs0Po0nAx86Zw23Vg6B6CLuQf4nb8PPD1Ml79Us1tVLddMMWSE6hSzH9xsTYIvXTqEN5H++vn2/PJ7v+isQXoD7r6jf5/kHn4WXvv/TvngaP9x9ar0z/C0E8ahtkBwAA","debug_symbols":"tZXdjoMgEIXfhWsvmBkQ8FWaprEtbUyMNVY32TS++45d8ecCssnu3nhQ5IMjR+Ylrv483E9Vc3s8RXF4iXNX1XV1P9WPS9lXj4afvoScLqBEoTIBWhSGJRcFSFbDCqx2VvetyGOAX0dg1aw4K4kCeRyqSccxE2GmU995P020mZoX1Jadb3pRNENdZ+KjrIf3S8+2bN7alx33MtE3V1YG3qraT60xW0fL+FCQKO08nNvOLgiQegeBBASVCQzMzQaBOwQmEFYaCAwr7WoltzsGxRmEWruZwW2jY4yUFUIVlkFKRa3oP7CS/7MVtLRYkfFdsXGEsSYgjEMXW4RLGKFcYzBCufu1ERU3koi5AwwJdaBcPOSJiKIjCtngto7uK6QySrydy/cgZWOQn5rREDWTQCijQryU2fyxen9wQCqitBwcbITWVVizZ5gEQzpaINLpaMLApiC4RoyPMIhCUjnVuVwgOqd9To98V16qblcYxonWVeW59vPtbWgum97+sw09obC03ePir0PnJ9KmuvD1wJtKeOQiwkXjQJSRPo7T1F8=","expression_width":{"Bounded":{"width":4}}},{"name":"get_assignment","hash":"10396792858394111973","is_unconstrained":true,"custom_attributes":["external","view","public"],"abi":{"parameters":[{"name":"sender_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"5203781738663661338":{"error_kind":"string","string":"Function get_assignment can only be called statically"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tZnRbiI7DIbfhWsuEjt2kr7KarViu+wKCdGKbY90VPXdj834H6DSRBy6e9P/o8P8xI6TeOBt9WP7/fXXt93h59Pv1cOXt9X3426/3/36tn963Lzsng7237dV8j+5rh7KepXb6qGa9NVDTusV2bWcTXMohbKpvZ2KqZhKqJp2U3Mjv95C+6ScQnMohXJoCZVQDQ0/Dj92P/u8kkJzKIVyaAmVUA2toS00/CT8JPwk/MT92LSESqiG1tAW2ifVFJpDKTT8NPw0/DT8qr/f5qFSKIeWUAnV0BraQvukLYWGX3O/ZsqhJVRC7T62ee/2PrZ57hxaQiVUQ2uofS7buHufNKcEyAACMKAABOC2XoWpAhqgB+QEyAB3FgcGFIAA3FAdGqAHeI2z17wX+QQEYEDkOVMFNECkOnMCZAABIt2ZC0AAGuCl7KnPJXKeSwEIQAEV0ADIvCDzgswLMi/IvCDzgsx7IU+AzAsyL8i8IvOKzHs5T4DMKzKvyLyX9ARu2B3MsHikNQEygAB2eyEHu6v4wLykT+A1PUEGEIABNoziH+qFPYECKqABekBPgAxwZ0+vL4QJCkAA7uyF5IthAnf2SH05OJAvhwkywJzFd0ZfBR4pJQEooALMUHx7zREyZQIwwHxEHQSgAPOR6tDw5kgmUQLAmeBMcPZNfgIBKKAC4Mww9Jr3eiav+QkEoAAfWPNjJE1lTL6RT0AA8xHPmC+HCQRgPuo+WA6E5UCn5eAgcBY4C5yFAQUgAAXAWWB4qnn/UEWAigAVAXrNn+JS3FUxjIpheKmfoqgIsCJAL/5TXBXDqBhGRYAVzg3ODc4NATYE2BBgQ4ANzu1k+P6+XqEn+PZy3G69JbhoEqx1eN4ct4eX1cPhdb9fr/7Z7F9Pb/r9vDmc9GVztKs26u3hh6kZ/tztt07v6/PdaflWOyFSi9uNe5st7IC4MskDE6sFeJDWCwu6sqCBRUs1w6Oldg5F25UHL3uwlVIPD+MqSx6jUNg7nWkYXMpiKPIHQtG/HIqV4hxKWp6VtmxRW4VF7dSXBtEHgbAKIRDW/ulAynIggzLvmVCh3U7t5SIflCh1ZtSGsSzOax7VKLO3tpEPLm3J5NZgJC8GM7CQ2hCKtKSzhVxvHHlQosoVo9BCF7NS67VHHS0VxcRe7Dy+7q4cBhVatGP7KjWfc8Gabh+FYBTWICyOggbprKViFFXoXOOc9dpjUOU8r5OSzxNiZ/y1w6hArYVCIJT6ssegPoWw7Qin+xz6XBZZ7ouDGgZhnQ0te+hoTgmnojXe9U4P7bNH6/d5cJo9mNqyRx9VFyqjFr3LoRfsOV3uG4PttTS3Cbo8rzyY11IU9VnKZafR/0c6y/l4ljunlecKNWx3efyJUDLPFZpLu2+l1DxvXXWwXrn9XQ973pxj0dru86hzr2GPncurvuTPrpSRw20rZeRw60rxQv5keQ3T2c8bT6fldA6PeEkIRa0fXTziy+Bw1coYh1XXZbPyIR2jEm15PhAanyfWvla4q+G5OKE/NDySRq3b/KRknRsvjkJGh3zqPJukLosttdDIhM49tT2z5UWTUSMqOk+uMS825sPVkuZGlO5cb4pB9CqfXbEDh+HpeFMUQ4eborjxhP7o8NVebh53x6vfD97d6rjbfN9v4+XP18PjxdWXf59xBb8/PB+fHrc/Xo9bdzr/CGF/vnDiNRN/9e987aXV1Jq6+svsV+2ZmEm/vvtg/gM=","expression_width":{"Bounded":{"width":4}}},{"name":"get_event_id","hash":"14823610970726781363","is_unconstrained":true,"custom_attributes":["external","view","public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"8228371833434187583":{"error_kind":"string","string":"Trying to read from uninitialized PublicImmutable"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"17875722597681684228":{"error_kind":"string","string":"Function get_event_id can only be called statically"}}},"bytecode":"H4sIAAAAAAAA/+1aP4gcVRh/szuzu7M72bmLCqnC2CgIFsk1goQQkyu0UEhEsDqW7BoWLkb21hDBwlIEWztbLVSwsLUUxM7GwlqwsxNSheTl3nf3299+8/bNzG7+wH5wvLn3/X/v+/P2zUTmGDI33prMDyZ3Jx/PD6Zj+3/k5mOzCJFZAZFnTlO275A9h2sBT/vRX2GCIOqRrmr8X+z3WGAlfvOYPzJ19R/7b3lq+m86brwG/GiLyO2a032wz0P3nHn4G9p2rQc8NfijsyX6xTYLV+vJbvfN8Tq87JwdPPrbccjR3dvvfXLzznhyZTyeTY6OMLZ5fX1QRWargsxzLPPdTw8Ppx9NJ7P9e9Oj+ZLstiJbnltG943tQjoELf4tFCYIophsfMmNdm9ehb2R+ROf3z66MR/Npzevjg4PQxazbGFj4jkHBrwGRQppLBQmDDKz6CDaInJjmK8QxLEWiLzZKD81zRIyInmij/2TdRLfE8WWXMHhviEO9SSKnicli/fLQmG8cBIyvBYiG+V2YL7CviShcSDyU7PsY5046JC+sjUV37uKLbmC473rKnq6ip7nSZbEUGaWYyoqGUUPz7Eerieop71GPUiTkJ7OGvRIXnTJn8KEQW6W86pLdvbWaGdKNIWpZiceZlOS3Qf6wgRBR3gHILdKnsdky/tutHstB0ZZxwwZ3Sj6z9TTH9zfRH5KttSta2dIH/vHdW2o2JIruD48Iw71DBU9mqzWBmRp9SMjnJbzWp4NCKfFtuWfuedM8asLdB/APOpOwF88n8kPg5joJajs/x+6uaGiOyYc90rEYbz1CIexn5APWpzhnO9MInSZwie5Ifk3JNsLEwTB5wqRn5pG+R75Ylk7V4h/eT19sejbUfRp+7Bj9DVF/SIL+7vIFRq0H2mr2m/z4/XoVA+vE8ebb121nNVql1YjuA6gr1wPQ2tEBj5IjWiap1h/URfqixWfsWbFRP+ZGxv2OrMLfIZkNTgDtLmHf+lGu06fk/yafbP1pGMcczMkxnFPuJ+FxjjHcWgfZH1lffA7s+hjWR/8yiz6W7cP/gt8X7vnbR9UYdsHSd+2Dz6dPig1QsvFkH6G9GX97Ac3brKfrapxP5lFX+rWuD+A72f33LTGaXdYgsPf/xxzgjPgA875apzQZQof17iaPTy4xon81Cz7XKfGZaRvVY1rcpdQlvvaPmCNwzVF/SKL77Qx53x3ZinhtHsqrSZE9Nz2+IT1RYt94a3ysorjogzqvKyKFdnyzC+rWiV2lb2siknH7260a/1WdGrzi2zzjfmd2ejW5PpkNGa7tLzR7O+X0Nl5re5wTeI7UMThXnNN0s5kYrfEslZXtR4h9H8C3z8kU8sv7U5c6HOFXrub0s6ReYCsxKNbO+/kHt1oF/Ky7rI6oZ2BZG0anoGSdf5OshCyVr47xB3A5YRbx5mJa2fZmYnjU3sPiL5KrdTOKHgOkTNKSO5yT0YcxgnnLq4v524Otmh+iNyY6P8DvihalKntsXbvLfS7Cj3uO+cP5tZugCxf7p5V6Hc9utEu5GXdbKfwabkrc5vIXawnnLu+umUhZK20fcqJHtemau5yzmPucl5jbA/BZ47PdeWu3KE8b7k7iE75zm9zd5u75tnN3fMbyl15D9hs3+7J96cnfidm8XeUIfkx0b/iBPA7f1nnwvjh79/+/+uXdy7e5nsSC+J7v4H8zujNS4Nvf93blPz7L1x/cPHSQbxKvsQEfyuEPHIGjgHXUeTFRH8B6uEe5KDMsT47d8VDF5WMms1oj8ylCn1boRfdfYVecAPAYQ1BGlwvlIW/25D+shMge4LfvuC9Juvnj6w1u3GOv78cKPQDhd76+QblVZNv1CzwN3U4h7qb5MLsQvbN3o/fX16VCw8BRl+Ly34vAAA=","debug_symbols":"tZnvbho7EMXfZT/ng+2Z8Z+8SlVVNCUVEiIRTa50FeXd78zunAV6ZYuS9EvOj8AePPaxd4C36cf2++vPb7vD49Ov6f7L2/T9uNvvdz+/7Z8eNi+7p4P+920K9ifKdM93U8zTfVEp030MqlU1qrZFU3CNqvrylFRFlVx5uk/2f3HNrsW1urZFKbhG1+RKru5H7kfmp+9DxbW6tkU5uEbX5Equ7Cqu7sfux+7H7ifmR6rRNbmSK7uKa3YtrtW1LZrdL7tfdr/sftler/Of26IluEbX5Equ7Cqu2bW4ul8xv3o31eAaXZOrXke63lVfR7q+LbhG1+RKruyq70s67pZdi2t1bYvGEAARkADmadELDBBABhRABZizrlCMARABCWCG2UAAGWCGFnRL+ALNwTK+gE9uTALIgAKoAF+xSAHgcxwpAQjAgLrMe2Sf6MgJQAAGCCADfLojVwAmXDDhggkXTLiFdwEGYMIFEy6YcMGEW4RnsAwvgAnPmHCL8QIMMMNmoIZslVrEF2gOFvIF9HJOBnoV28AsxwtUQHOwKC8QAToMtjetBGCAADKgACqgOVj4eT70IiABCGDOFiTbAQuYs1Vqe0CsCtsEYgOzXWCQbBdINUhLpSkQgAECUENpBl5yigEQAeqTgwEBGKA+eT6qM15cABUA5wTnBGc72RcgAAMEAOcEQ8u85TlZ5hcgAANsYFbgHH4bIfmpkzgA1CeboW2HBQhgBdotBNshYTukeTvMAGeGs8BZIiABCMAAOAsM58zb4DMKzCgwo0DL/FxXXq/CMDKGYVGfqygosKBAC/9cV8EwCoZRUGCBc4FzgXNFgRUFVhRYUWCF83zcx/f3uwmNwLeX43ZrfcBZZ6D9wvPmuD28TPeH1/3+bvpns3+dX/TreXOY9WVz1Ge1+u3hh6oaPu72W6P3u9PVoX+p3gZC9cuVW10t9C5wYRIHJrry8NDZP7NIFxZpYFFDifCooZ5KyfXCg/oepMFp7qFcpOcxKoWszVmGQczdUuQTSsl/uRQN3lpK6K9K7VuUWmBRWmq9QbRBIZTtLF4Kodw+XAj3CxnEvMWEhDa9R/dDPohoakTIhrJ01zWOMkpkfa3PB3HtmVxbjMRuMQMLbhkW3OppEHJ5cMRBRDNXJDRLODs36m9TWgb5YsbZVbiUvscgoxzaWoreGvseg5SWchpHORsHxXx5gIVRLQUHaZGzcfzPY5B0WvcK61Vw0Nv7pcMopNo0IaPauPQ9BhmVhIUVCrc5rEuSo9xWR1rTlUj3eddjkFDtuLGq2mqXGz1yWz1qu82DwupBqfY9RgnltG6UfJNDY5w7TW4bg563aW0Vcn9dabCuzBn5ZD7vNtofTCefbtFy47LSmlDFepPHZ5QSaU1o5HrbTil2Si87pQz2K9W/66EfNddacqm3eZS139APmv1dz/GjO2XkcN1OGTlcu1MsyB+M13A62+ngaak/ncNbtKwRLSL92yuXT+iIuX5GSzxsONbbSpHYb1okfLgplvgZXfG1DVgM/cZn5CEFZ2nO1G/AhIft+en2dtFyxEuPwWcmvY7QPSlLf1ZHH5pCOs2qfpaNXZMyasFyWE0kU3dphidIWBv0dOMZlDGIVuSjp9jAYdgxXFXF0OGqKq7sWn53+KoPNw+748WPKe9mddxtvu+3/vDx9fBw9uzLv894Bj/GPB+fHrY/Xo9bczr9IqN/vlCId5TiV/vCWx9a0lNjexjtWT3l9fuCr+82mP8A","expression_width":{"Bounded":{"width":4}}},{"name":"get_game_state","hash":"9365920008120715497","is_unconstrained":true,"custom_attributes":["external","view","public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"9329803505245596199":{"error_kind":"string","string":"Function get_game_state can only be called statically"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7VUwUrDQBCdTWKNtoqKoqcSUCh41KN4ENuDPSjYo4eyNGsJpFSaKMWTfog/4NmrR3/Bg36Hd7NmU6bTJN1E+mCZySbvzbzdzTKIsa5iX4TdPh+IbhDyUMgZpt5YMA0Gc8By5tLLHapZW0UDscxoOKAFZpNqxfhPLZsKFuLDH59B2fqxf8kp6R8qKjYRH/eS6C5Ho4byNZXXcvj/7K1pI04JPtvKqC+xCrGPunquRmND5fxhcHXXG7rizHVHIgjw6aTrk4cimkYBzT2qeXnv+96tJ0atsReEM9pminaSG5DujfaFv8NIO78SDmiBWaTHbRXl3hyoXHreUfnE80XQie4Br3fOfV9nMbMW1iKcXdRAQ+XUpIQDWjCqyNSk+U44HPG+uBbc1T0IuofQhNlNNwjPhPRLh2oYGfXkqEH2ZSF/ruRitEgNB3QwbjHUi8QSTPcIRN8i3++ruILqJ9HS6OPr4+fzrX002CR8CeyzrH6Fn5xWX96PF6X//Fj/bt+8Nubp/wKClLmc1gcAAA==","debug_symbols":"tZXNbqswEIXfxWsWnhn/jHmVKopIQiokRCIKV7qKePc79GJ+FrYqtd1w7Jj5mBMf2S91qy/j+7np7o8PVb691KVv2rZ5P7ePazU0j05+fSk9P8Co0hQKrCq9iFMlaFEvCqK8aPivKDUgryOIWlFclFSJUodmUcEhirpF/azTVKjYwXno63puYNeSNPqs+robVNmNbVuoP1U7fr708ay6Tx2qXlblC3V3ExXgvWnreTQVW7VOl4JGzUu5jAOvCND2AIEMBI2PDHR+h8ADAjMI1h4igzVvVhwfGJRmEFobFoaMvU0xclYITWyDjElasT9gxf2yFWRarej0rnAa4dlHhA8YUk2EjBFyFqMRcuHbRkzaSCbmATAmNIAJ6ZBnIoqBKGZDxja5r5DLKMl2rv8HGU5BvmrGQtJMBmHYxi4M+60Jezw4IBdRWg8OMUJbF+yPDJ9h6EArRAebTBhwDoJbxOQIgyQkl1Pr9AqxjtI5zdvBnR1vUhDMpJ193BkOW8TISdZPMq2uTX+4t6YZ1TfVpa2X6X3srrvV4e8zrsR779k/rvVt7OuZtLv85PlGuiB7kjsO5okriE/T/Ol/","expression_width":{"Bounded":{"width":4}}},{"name":"get_participant","hash":"3416406439935803231","is_unconstrained":true,"custom_attributes":["external","view","public"],"abi":{"parameters":[{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"2925407043258509040":{"error_kind":"string","string":"Function get_participant can only be called statically"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tZnRbiI7DIbfhWsuEjt2kr7KarViu+wKCdGKbY90VPXdj834H6DSRBy6e9P/o8P8xI6TeOBt9WP7/fXXt93h59Pv1cOXt9X3426/3/36tn963Lzsng7237dV8j+5rh7KepXb6qGa9NVDTusV2bWcTXMohbKpvZ2KqZhKqJp2U3Mjv95C+6ScQnMohXJoCZVQDQ0/Dj92P/u8kkJzKIVyaAmVUA2toS00/CT8JPwk/MT92LSESqiG1tAW2ifVFJpDKTT8NPw0/DT8qr/f5qFSKIeWUAnV0BraQvukLYWGX3O/ZsqhJVRC7T62ee/2PrZ57hxaQiVUQ2uofS7buHufNKcEyAACMKAABOC2XoWpAhqgB+QEyAB3FgcGFIAA3FAdGqAHeI2z17wX+QQEYEDkOVMFNECkOnMCZAABIt2ZC0AAGuCl7KnPJXKeSwEIQAEV0ADIvCDzgswLMi/IvCDzgsx7IU+AzAsyL8i8IvOKzHs5T4DMKzKvyLyX9ARu2B3MsHikNQEygAB2eyEHu6v4wLykT+A1PUEGEIABNoziH+qFPYECKqABekBPgAxwZ0+vL4QJCkAA7uyF5IthAnf2SH05OJAvhwkywJzFd0ZfBR4pJQEooALMUHx7zREyZQIwwHxEHQSgAPOR6tDw5kgmUQLAmeBMcPZNfgIBKKAC4Mww9Jr3eiav+QkEoAAfWPNjJE1lTL6RT0AA8xHPmC+HCQRgPuo+WA6E5UCn5eAgcBY4C5yFAQUgAAXAWWB4qnn/UEWAigAVAXrNn+JS3FUxjIpheKmfoqgIsCJAL/5TXBXDqBhGRYAVzg3ODc4NATYE2BBgQ4ANzu1k+P6+XqEn+PZy3G69JbhoEqx1eN4ct4eX1cPhdb9fr/7Z7F9Pb/r9vDmc9GVztKs26u3hh6kZ/tztt07v6/PdaflWOyFSi9uNe5st7IC4MskDE6sFeJDWCwu6sqCBRUs1w6Oldg5F25UHL3uwlVIPD+MqSx6jUNg7nWkYXMpiKPIHQtG/HIqV4hxKWp6VtmxRW4VF7dSXBtEHgbAKIRDW/ulAynIggzLvmVCh3U7t5SIflCh1ZtSGsSzOax7VKLO3tpEPLm3J5NZgJC8GM7AQIqRUbEefLeR648iDElWuGIUWupiVWq896mipKCb2YufxdXflMKjQoh3bV6n5nAvWdPsoBKOwBmFxFDRIZy0Vo6hC5xrnrNcegyrneZ2UfJ4QO+OvHUYFai0UAqHUlz14VBjYdoTTfQ59Loss98VBDYOwzoaWPXQ0p4RT0RrveqeH9tmj9fs8OM0eTG3Zo4+qC5VRi97l0Av2nC73jcH2WprbBF2eVx7MaymK+izlstPo/yOd5Xw8y53TynOFGra7PP5EKJnnCs2l3bdSap63rjpYr9z+roc9b86xaG33edS517DHzuVVX/JnV8rI4baVMnK4daV4IX+yvIbp7OeNp9NyOodHvCSEotaPLh7xZXC4amWMw6rrsln5kI5RibY8HwiNzxNrXyvc1fBczOyHhkfSqHWbn5Ssc+PFUcjokE+dZ5PUZbGlFhqZ0Lmntme2vGgyakRF58k15sXGfLha0tyI0p3rTTGIXuWzK3bgMDwdb4pi6HBTFDee0B8dvtrLzePuePX7wbtbHXeb7/ttvPz5eni8uPry7zOu4PeH5+PT4/bH63HrTucfIezPF068ZuKv/p2vvbSaWlNXf5n9qj0TM+nXdx/Mfw==","expression_width":{"Bounded":{"width":4}}},{"name":"get_participant_count","hash":"7066118797074182880","is_unconstrained":true,"custom_attributes":["external","view","public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"11073082467582396015":{"error_kind":"string","string":"Function get_participant_count can only be called statically"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7VUzUrDQBCeTdIabQUVRU8SUFA86lE8iO1BDwr2AcrSxBJIm5BspRfB1/DgE3j16lEfoYe+h3ezZlO20yTdRPxgmUl2v29m9mcIJNgRtu+wbkBD5vbcgA5Zt+ePhoxPELHAgHkQWAJS8K8w6omYNIXVJLIeDwuUQEwUtBz/uW1iwVJ8+OUTqBo/qZ9zKtYPdWFbEl/OJdVdiUdT8teF3yzg/zG3lilxKvDJVk58jjVI6tgX3414bAifPg7ugp5vO5e2HTpRJF9SvD9FKKOpldDcw5q3I89zH1wnbI/diC1o6xnaqa9Bdm04L3mdjKz7y2GBEoiBctwWlp/NofB5zWkzmNV8HXUYjXvCFfU8lc3M21gDcXalBI6Ej4vksEAJtYZU1Cz5DvND2nfuHWqrXgTVS6jD4qHjB6BDdtPBGlpOPD7fhPxmwR9X2hgNxLNABeM2kXLhqMF8joD0DbT+QNhVKX5qDYU8pp/fk/eb08Em4nPIdVbVr9Pzi8brx9l/6b+8PU2Op1/+Mv0fWwInteQHAAA=","debug_symbols":"tZXLboMwEEX/xWsWnhk/+ZUqikjiVEiIRAQqVRH/3iHFPBa2KrXdcO2YOcyNr+ynuITT8H6s2+vtIcq3pzh1ddPU78fmdq76+tbyr08hpwcoUapCgBalZTGiBMlqWYHVzeq/FbkG+HUEVs2Ks5IoketQzco4RFYzq510HAsROzj2XQhTA5uWuNF71YW2F2U7NE0hPqpmeL30uFftS/uq41X+QmgvrAy81k2YRmOxVst0KUiUbi7nsXcLAqTeQSADQWUjA43dIHCHwAzCSQuR4aRbrRi3Y1CaQai1nxk8tjrFyFkhVLENUippRf+BFfPPVtDRYkWmd8WlEdbZiLAefaoJnzFCRmM0Qsb/2ohKG8nE3APGhHpQPh3yTETRE8Vs8Fgn9xVyGSXezuX/IOVSkJ+a0ZA0k0Fo6aIVDbDGXO8PDshFlJaDg43Q2oWze4bNMKSnBSK9TiYMXA6Ca8T4CIMkJJdTbeQC0YbSOc3bwY0dq1IQzJ5Ay9aAkmvIyHDaDzytznW3u7nGCdbV1akJ8/Q6tOfNav95jyvx5rt3t3O4DF2YSJvrj59vJAvSB77lYJqYgtxhnD79BQ==","expression_width":{"Bounded":{"width":4}}},{"name":"get_sender_count","hash":"1365580388285210967","is_unconstrained":true,"custom_attributes":["external","view","public"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},"error_types":{"302510152106085397":{"error_kind":"string","string":"Function get_sender_count can only be called statically"},"459713770342432051":{"error_kind":"string","string":"Not initialized"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7VUwUrDQBCdTdY22goqFj1JQEHwWI/Fg9ge9KBgP6AszVoCaStJKj36Af6Cf+FNPPoLHvwP73btpk6nSbuJ+CDMZJP3Zt5msgym2NKxJ+NOJAeeDDvd4WgQqzWmn3GYB4MVYEvWsgqe6HVHRwvx7MnlghGYQ+rl4z+2HCqYiw8/fAZF60/9K05B/1DSsYn4uJdEtzy5qijf1Hl1Cf+PvTUdxCnAZzsZ9RU2YOrjQN9X4HfWxEP/5r479OS554UyivB80v1ZhjyaVg7Nfap5PQoC/86XYWvsR/GCtp2ineQWpHujfeH3MNLmV8EFIzBOetzVUX2bI50rzzWdzzxfRu1YxH73QgSByWZmbSwnnD3UwLHOqUkFF4xQriBTs+bb8TAUPXkrhWc6CKZDaMPiR6c/gA3phw7VsDLqqedVyD4s1M+VHIyc8FwwwbjFUC8KazDfIxB9Tt4/1HEd1U8iN+jj8/3r4+Wq3t8mfAXss6h+STTOKs9vp/+lz+uvot94qq3S/wZHHVR82gcAAA==","debug_symbols":"tZXdaoQwEIXfJddeZGby66uUZXF3s0UQd7FaKIvv3nFr/CkkFNreeBJjPuckh+QhLuE0vB7r9np7E+XLQ5y6umnq12NzO1d9fWv57UPI6QFKlKoQoEVpWYwoQbJaVmB1s/ovRZ4D/DkCq2bFWUmUyPNQzco4RFYzq510HAsRKzj2XQhTAZuSuNB71YW2F2U7NE0h3qtmeH70dq/ap/ZVx6P8h9BeWBl4rZswtcZinS3TU0GidPN0bnu3IEDqHQQyEFQ2MtDYDQJ3CMwgnLQQGU661YpxOwalGYRa+5nBbatTjJwVQhXLIKWSVvQfWDH/bAUdLVZkeldcGmGdjQjr0aeK8BkjZDRGI2T8r42otJFMzD1gTKgH5dMhz0QUPVHMBrd1cl8hl1Hi7VzWg5RLQX5qRkPSTAahScV4abJrzPX+4IBcRGk5ONgIrVU4u2fYDEN6WiDS62TCwOUguEaMjzBIQnI51UYuEG0ondO8HdzY2azrNwhmTyC3nEBKriEjw2k/cLc6193u5honWFdXpybM3evQnjej/cc9jsSb797dzuEydGEiba4/fr6QLEgf+JaDqWMKcodx+vUn","expression_width":{"Bounded":{"width":4}}},{"name":"get_sender_nullifier","hash":"1617406623979100568","is_unconstrained":true,"custom_attributes":["external","view","public"],"abi":{"parameters":[{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"7199774323969043579":{"error_kind":"string","string":"Function get_sender_nullifier can only be called statically"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tZnhbho7EIXfhd/8sGc8YzuvUlUVTWmFhEhEkytdRXn3O8POWaBXa1HS/sn5yLIHz/h4bZK31bft19cfX3aH708/Vw+f3lZfj7v9fvfjy/7pcfOyezrYb99WyX/kunoo61Vuq4dq0lcPOa1XZNdyNs2hFMqm9nYqpmIqoWraTc2N/HoL7ZNyCs2hFMqhJVRCNTT8OPzY/ezzSgrNoRTKoSVUQjW0hrbQ8JPwk/CT8BP3Y9MSKqEaWkNbaJ9UU2gOpdDw0/DT8NPwq/5+m4dKoRxaQiVUQ2toC+2TthQafs39mimHllAJtfvY5r3b+9jmuXNoCZVQDa2h9rls4+590pwSIAMIwIACEIDbegpTBTRAD8gJkAHuLA4MKAABuKE6NEAP8IyzZ95DPgEBGBB9zlQBDRCtzpwAGUCAaHfmAhCABniUvfW5RM9zKQABKKACGgCdF3Re0HlB5wWdF3Re0HkP8gTovKDzgs4rOq/ovMd5AnRe0XlF5z3SE7hhdzDD4pXWBMgAAtjthRzsruID80ifwDM9QQYQgAE2jOIf6sGeQAEV0AA9oCdABrizt9cXwgQFIAB39iD5YpjAnb1SXw4O5MthggwwZ/Eno68Cr5SSABRQAWYo/njNUTJlAjDAfEQdBKAA85Hq0PDmaCZRAsCZ4Exw9of8BAJQQAXAmWHomfc8k2d+AgEowAfWfBtJU4zJH+QTEMB8xDvmy2ECAZiPug+WA2E50Gk5OAicBc4CZ2FAAQhAAXAWGJ4y7x+qKFBRoKJAz/ypLsVdFcOoGIZH/VRFRYEVBXr4T3VVDKNiGBUFVjg3ODc4NxTYUGBDgQ0FNji3k+H7+3qFM8GXl+N260eCi0OCHR2eN8ft4WX1cHjd79erfzb719Obfj5vDid92Rztqo16e/hmaobfd/ut0/v6fHdavtV2iNTiduPeZgvbIK5M8sDEsgAP0nphQVcWNLBoqWZ4tNTOpWi78uBlD7Yo9fAwrrLkMSqF/aQzDYNLWSxF/kAp+pdLsSjOpaTlWWnLFrVVWNROfWkQfVAIqxAKYe0fLqQsFzKIec+EhHbbtZdDPogodWZkw1gW5zWPMsrsR9voB5e2ZHJrMZIXixlYSGmIqEg690OuHxx5EFHlilFooYtZqfXao46WimJiL548vu6uHAYJLdrx+Co1n3vBmm4fhWAUdkBYHAUN2llLxSiq0DnjnPXaY5ByntdJsbvgYHv8tcMooHaEQiF0Man/8xjkUwiPHeF0n0OfY5HlvjqoYRB2sqFlDx3NKWFXtIN3vdND++zR+n0enGYPprbs0UfpQjJq0bscesEzp8t9Y7BnLc3HBF2eVx7MaymKfJZyedLov9HOct6e5c5p5Tmhhu0ujz9RSuY5obm0+1ZKzfOjqw7WK7e/62HfN+datLb7POp81rCvncurvuSPrpSRw20rZeRw60rxIH8wXsN29vODp9NyO4dbvCSUonYeXdziy2Bz1coYh6Xr8rDySztGEW153hAanyfW/qxw14GH8tKBR9Lo6DZ/U7KTGy+OQkabfOo8m6Qui0dqoZEJnc/U9p0tL5qMDqKi8+Qa8+LBfLha0nwQpTvXm2IQvcpHV+zAYbg73lTF0OGmKm7coX91+GwvN4+749X/D97d6rjbfN1v4+X318PjxdWXf59xBf9/eD4+PW6/vR637nT+J4T9+MSJ10z82f/may8tU2vq6i+zX7XvxEz6+d0H8x8=","expression_width":{"Bounded":{"width":4}}},{"name":"get_sender_randomness","hash":"16672743146210309619","is_unconstrained":true,"custom_attributes":["external","view","public"],"abi":{"parameters":[{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"1299872859832894838":{"error_kind":"string","string":"Function get_sender_randomness can only be called statically"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tZnhbho7EIXfhd/8sGc8YzuvUlUVTUmFhEhEkytdRXn3O8POWaDSWlzS/sn5yLIHz/h4bZL31Y/t97ef33aHp+dfq4cv76vvx91+v/v5bf/8uHndPR/st++r5D9yXT2U9Sq31UM16auHnNYrsms5m+ZQCmVTezsVUzGVUDXtpuZGfr2F9kk5heZQCuXQEiqhGhp+HH7sfvZ5JYXmUArl0BIqoRpaQ1to+En4SfhJ+In7sWkJlVANraEttE+qKTSHUmj4afhp+Gn4VX+/zUOlUA4toRKqoTW0hfZJWwoNv+Z+zZRDS6iE2n1s897tfWzz3Dm0hEqohtZQ+1y2cfc+aU4JkAEEYEABCMBtPYWpAhqgB+QEyAB3FgcGFIAA3FAdGqAHeMbZM+8hn4AADIg+Z6qABohWZ06ADCBAtDtzAQhAAzzK3vpcoue5FIAAFFABDYDOCzov6Lyg84LOCzov6LwHeQJ0XtB5QecVnVd03uM8ATqv6Lyi8x7pCdywO5hh8UprAmQAAez2Qg52V/GBeaRP4JmeIAMIwAAbRvEP9WBPoIAKaIAe0BMgA9zZ2+sLYYICEIA7e5B8MUzgzl6pLwcH8uUwQQaYs/iT0VeBV0pJAAqoADMUf7zmKJkyARhgPqIOAlCA+Uh1aHhzNJMoAeBMcCY4+0N+AgEooALgzDD0zHueyTM/gQAU4ANrvo2kKcbkD/IJCGA+4h3z5TCBAMxH3QfLgbAc6LQcHATOAmeBszCgAASgADgLDE+Z9w9VFKgoUFGgZ/5Ul+KuimFUDMOjfqqiosCKAj38p7oqhlExjIoCK5wbnBucGwpsKLChwIYCG5zbyfDjY73CmeDb63G79SPBxSHBjg4vm+P28Lp6OLzt9+vVP5v92+lNv142h5O+bo521Ua9PfwwNcOn3X7r9LE+352Wb7UdIrW43bi32cI2iCuTPDCxLMCDtF5Y0JUFDSxaqhkeLbVzKdquPHjZgy1KPTyMqyx5jEphP+lMw+BSFkuRP1CK/uVSLIpzKWl5VtqyRW0VFrVTXxpEHxTCKoRCWPunCynLhQxi3jMhod127eWQDyJKnRnZMJbFec2jjDL70Tb6waUtmdxajOTFYgYWooR4icq5pXL94MiDiCpXjEILXcxKrdcedbRUFBN78eTxdXflMEho0Y7HV6n53AvWdPsoBKOwA8LiKGjQzloqRlGFzhnnrNceg5TzvE6K3QUH2+OvHUYBtSMUCqHUlz0G+ZRzLjjd59DnWGS5rw5qGISdbGjZQ0dzStgV7eBd7/TQPnu0fp8Hp9mDqS179FG6kIxa9C6HXvDM6XLfGOxZS/MxQZfnlQfzWooin6VcnjT6/2hnOW/Pcue08pxQw3aXx58oJfOc0FzafSul5vnRVQfrldvf9bDvm3MtWtt9HnU+a9jXzuVVX/JnV8rI4baVMnK4daV4kD8Zr2E7+/nB02m5ncMtXhJKUTuPLm7xZbC5amWMw9J1eVj5rR2jiLY8bwiNzxNrf1a468CjfenAI2l0dJu/KdnJjRdHIaNNPnWeTVKXxSO10MiEzmdq+86WF01GB1HReXKNefFgPlwtaT6I0p3rTTGIXuWzK3bgMNwdb6pi6HBTFTfu0L87fLWXm8fd8er/Bx9uddxtvu+38fLp7fB4cfX13xdcwf8fXo7Pj9sfb8etO53/CWE/vnDiNRN/9b/52kvL1Jq6+svsV+07MZN+/fDB/Ac=","expression_width":{"Bounded":{"width":4}}},{"name":"process_message","hash":"7243159446478293566","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13921208329385594075":{"error_kind":"fmtstring","length":40,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"public_dispatch","hash":"1435422039050924067","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"302510152106085397":{"error_kind":"string","string":"Function get_sender_count can only be called statically"},"459713770342432051":{"error_kind":"string","string":"Not initialized"},"1299872859832894838":{"error_kind":"string","string":"Function get_sender_randomness can only be called statically"},"1643290557656260443":{"error_kind":"string","string":"Only admin"},"2925407043258509040":{"error_kind":"string","string":"Function get_participant can only be called statically"},"5203781738663661338":{"error_kind":"string","string":"Function get_assignment can only be called statically"},"7182175156193537826":{"error_kind":"string","string":"Wrong state"},"7199774323969043579":{"error_kind":"string","string":"Function get_sender_nullifier can only be called statically"},"8228371833434187583":{"error_kind":"string","string":"Trying to read from uninitialized PublicImmutable"},"9329803505245596199":{"error_kind":"string","string":"Function get_game_state can only be called statically"},"9345055721478160917":{"error_kind":"string","string":"Function get_admin can only be called statically"},"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"10544136526549435900":{"error_kind":"string","string":"Need at least 2"},"11073082467582396015":{"error_kind":"string","string":"Function get_participant_count can only be called statically"},"12000676934365261133":{"error_kind":"string","string":"Already disclosed"},"13232839614478528037":{"error_kind":"string","string":"Too many"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"13797760336213010086":{"error_kind":"string","string":"Already assigned"},"13870217519242821031":{"error_kind":"string","string":"Nullifier spent"},"14189827170432234740":{"error_kind":"string","string":"Cannot choose yourself"},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14716172601447261746":{"error_kind":"string","string":"Invalid index"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15660711043745905308":{"error_kind":"string","string":"Already complete"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16810041750452690220":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"17875722597681684228":{"error_kind":"string","string":"Function get_event_id can only be called statically"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"register_participants","hash":"16584292148392438150","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"p0","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"p1","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"p2","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"p3","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"p4","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"p5","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"p6","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"p7","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"1643290557656260443":{"error_kind":"string","string":"Only admin"},"7182175156193537826":{"error_kind":"string","string":"Wrong state"},"10544136526549435900":{"error_kind":"string","string":"Need at least 2"},"13232839614478528037":{"error_kind":"string","string":"Too many"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"submit_randomness","hash":"11838485479902354649","is_unconstrained":true,"custom_attributes":["external","public"],"abi":{"parameters":[{"name":"nullifier","type":{"kind":"field"},"visibility":"private"},{"name":"randomness","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"7182175156193537826":{"error_kind":"string","string":"Wrong state"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"13870217519242821031":{"error_kind":"string","string":"Nullifier spent"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"sync_private_state","hash":"3049904725841620809","is_unconstrained":true,"custom_attributes":["external","utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"9921926525851912681":{"error_kind":"fmtstring","length":98,"item_types":[]},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13921208329385594075":{"error_kind":"fmtstring","length":40,"item_types":[]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"tf3fzuQ6cqUP38s+9kHyTwRJ38pgYLQ9PYMGGm2jbX/AB8P3/ksGFfGw3u1kqTLffeJ6vLsqlkRyrZQoivqv3/7Pn//5P//fP/3lb//3X//9t3/8X//12z///S9//etf/t8//fVf/+VP//GXf/3b87/+12+P+X9K/e0fyz/8VuS3f9TnH/rbP/bnH2390dcfw/6oj/VHWn/k9UdZf9T1h6w/VpW6qtRVpa4qsqrIqiKriqwqsqrIqiKriqwqsqrIqqKriq4quqroqqKriq4quqroqqKriq4qbVVpq0pbVdqq0laVtqq0VaWtKm1VaatKX1X6qtJXlb6q9FWlryp9VemrSl9V+qoyVpWxqoxVZawqY1UZq8pYVcaqMlaVsaqkx+P6M11/5uvPcv1Zrz/l+lOvP9v1Z7/+vOqlq1666qWrXnrWS48J1UEc1OFZM5UJ3WFckB8Oz7pJJzwL5/mvcnGoDuKgDs3hWTnXCeOC8nBIDrOyTCgO1WEe8zydOe4XNIdn5ZImjAvm+F+QHLJDcagO4qAOzcErV68sXlm88vRFme0znbGgOoiDOjSH7jAumD5ZkBy8snpl9crqldUrq1dWr6xeuXnl5pWbV25euXnl5pWbV25eeXqpzL6YbjKYflqQHLJDcagO4qAOzcErd688vPLwysMrD688vPLwysMrD688vPK4KufHwyE5ZIfiUB3EQR2aQ3fwyskrJ6+cvHLyyskrJ6+cvHLyyskrJ6+cvXL2ytkrZ6+cvXL2ytkrZ6+cvXL2ysUrF69cvHLxysUrF69cvHLxysUrF69cvXL1ytUrV69sHuwTxEEdmkN3GBeYBw2SQ3YoDl5ZvLJ45enBmiZ0h3HB9GDVCckhOxSH6iAO6tAcusO4oHnl5pWbV25XIuVWHcRBHZpDd7gSKfeHQ3LIDl65e+XulacH65jQHLrDuGB6cEFyyA7FoTqIg1ceXnl45XFVLtOD8piQHLJDcagO4qAOzaE7jAuSV05eOXnl6UFpE6qDOKhDc+gO44LpwQXJITt45eyVs1fOXjl75eyVs1cuXrl45eKVi1cuXrl45eKVi1cuXrl45eqVq1euXrl65eqVq1euXrl65eqVq1cWryxeWbyyeGXxyuKVxSuLVxavLF5ZvbJ6ZfXK6pXVK6tXVq+sXlm9snrl5pWbV25euXnl5pWbV25euXnl5pWbV+5euXvl7pW7V+5euXvl7pW7V+5euXvl4ZWHVx5eeXjl4ZWHVx5eeXjl4ZXHVbk+Hg7JITsUh+ogDurQHLqDV05eOXnl5JXdg9U9WN2D1T1Y3YPVPVjdg9U9WN2D1T1Y3YPVPVjdg9U9WN2D1T1Y3YPVPVjdg9U9WN2D1T1Y3YPVPVjdg9U9WN2D1T1Y3YPVPVjdg9U9WN2D1T1Y3YPVPVjdg9U9WN2D1T1Y3YPVPVjdg9U9WN2D1T1Y3YPVPVjdg9U9WN2D1T1Y3YPVPVjdg9U9WN2D1T1Y3YPVPVjdg9U9WN2D1T1Y3YPVPVjdg9U9WN2D1T1Y3YPVPVjdg9U9WN2D1T1Y3YPVPVjdg9U9WN2D1T1Y3YPVPVjdg9U9WN2D4h4U96C4B8U9KO5BcQ+Ke1Dcg+IeFPeguAfFPSjuQXEPintQ3IPiHhT3oLgHxT0o7kFxD4p7UNyD4h4U96C4B8U9KO5BcQ+Ke1Dcg+IeFPeguAfFPSjuQXEPintQ3IPiHhT3oLgHxT0o7kFxD4p7UNyD4h4U96C4B8U9KO5BcQ+Ke1Dcg+IeFPeguAfFPSjuQXEPintQ3IPiHhT3oLgHxT0o7kFxD4p7UNyD4h4U96C4B8U9KO5BcQ+Ke1Dcg+IeFPeguAfFPSjuQXEPintQ3IPiHhT3oLgHxT0o7kFxD4p7UNyD4h4U96C4B8U9qO5BdQ+qe1Ddg+oeVPegugfVPajuQXUPqntQ3YPqHlT3oLoH1T2o7kF1D6p7UN2D6h5U96C6B9U9qO5BdQ+qe1Ddg+oeVPegugfVPajuQXUPqntQ3YPqHlT3oLoH1T2o7kF1D6p7UN2D6h5U96C6B9U9qO5BdQ+qe1Ddg+oeVPegugfVPajuQXUPqntQ3YPqHlT3oLoH1T2o7kF1D6p7UN2D6h5U96C6B9U9qO5BdQ+qe1Ddg+oeVPegugfVPajuQXUPqntQ3YPqHlT3oLoH1T2o7kF1D6p7UN2D6h5U96C6B9U9qO5BdQ+qe1Ddg8092NyDzT3Y3IPNPdjcg8092NyDzT3Y3IPNPdjcg8092NyDzT3Y3IPNPdjcg8092NyDzT3Y3IPNPdjcg8092NyDzT3Y3IPNPdjcg8092NyDzT3Y3IPNPdjcg8092NyDzT3Y3IPNPdjcg8092NyDzT3Y3IPNPdjcg8092NyDzT3Y3IPNPdjcg8092NyDzT3Y3IPNPdjcg8092NyDzT3Y3IPNPdjcg8092NyDzT3Y3IPNPdjcg8092NyDzT3Y3IPNPdjcg8092NyDzT3Y3IPNPdjcg8092NyDzT3Y3IPNPdjcg8092NyDzT3Y3IPNPdjcg8092NyDzT3Y3IPdPdjdg9092N2D3T3Y3YPdPdjdg9092N2D3T3Y3YPdPdjdg9092N2D3T3Y3YPdPdjdg9092N2D3T3Y3YPdPdjdg9092N2DfXpQHxPGBdODC56VtU7IDsWhOoiDOjSH7jAumB5c4JWrV65euXrl6pWrV65euXrl6pXFK4tXFq8sXlm8snhl8crilcUri1dWr6xeWb2yemX1yuqV1SurV1avrF65eeXmlZtXbl65eeXmlZtXbl65eeXmlbtX7l65e+XulbtX7l65e+XulbtX7l55eOXhlYdXHl55eOXhlYdXHl55eOVxVR6Ph0NyyA7FoTqIgzo0h+7glZNXTl45eeXklZNXTl45eeXklZNXTl45e+XslbNXzl45e+XslbNXzl45e+XslYtXdg8O9+BwDw734HAPDvfgcA8O9+BwDw734HAPDvfgcA8O9+BwDw734HAPDvfgcA8O9+BwDw734HAPDvfgcA8O9+BwDw734HAPDvfgcA8O9+BwDw734HAPDvfgcA8O9+BwDw734HAPDvfgcA8O9+BwDw734HAPDvfgcA8O9+BwDw734HAPDvfgcA8O9+BwDw734HAPDvfgcA8O9+BwDw734HAPDvfgcA8O9+BwDz4fyz+CUlAOKkE1SII0qAX1oNBIoZFCI4VGCo0UGik0Umik0EihkUIjh0YOjRwaOTRyaOTQyKGRQyOHRg6NEholNEpolNAooVFCo4RGCY0SGiU0amjU0KihUUOjhkYNjRoaNTRqaNTQkNCQ0JDQkNCQ0JDQkNCQ0JDQkNDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0Gih0UKjhUYLjRYaLTRaaLTQaKHRQqOHRg+NHho9NHpo9NDoodFDo4dGD40RGiM0RmiM0BihMUJjhMYIjREa4fMUPk/h8xQ+T+HzFD5P4fMUPk/h8xQ+T+HzFD5P4fMUPk/h8xQ+T+HzFD5P4fMUPk/h8xQ+T+HzFD5P4fMUPk/h8xQ+T+HzFD5P4fMUPk/h8xQ+T+HzFD5P4fMUPk/h8xQ+T+HzFD5P4fMUPk/h8xQ+T+HzFD5P4fMUPk/h8xQ+T+HzFD5P4fMUPk/h8xQ+T+HzFD5P4fMUPk/h8xQ+T+HzFD5P4fMUPk/h8xQ+T+HzFD5P4fMUPk/h8xQ+T+HzFD5P4fMUPk/h8xQ+T+HzFD5P4fMUPk/h8xQ+T+HzFD5P4fMUPk/h8xQ+T+HzFD5P4fMUPk/h8xQ+T+HzHD7P4fMcPs/h8xw+z+HzHD7P4fMcPs/h8xw+z+HzHD7P4fMcPs/h8xw+z+HzHD7P4fMcPs/h8xw+z+HzHD7P4fMcPs/h8xw+z+HzHD7P4fMcPs/h8xw+z+HzHD7P4fMcPs/h8xw+z+HzHD7P4fMcPs/h8xw+z+HzHD7P4fMcPs/h8xw+z+HzHD7P4fMcPs/h8xw+z+HzHD7P4fMcPs/h8xw+z+HzHD7P4fMcPs/h8xw+z+HzHD7P4fMcPs/h8xw+z+HzHD7P4fMcPs/h8xw+z+HzHD7P4fMcPs/h8xw+z+HzHD7P4fMcPs/h8xw+z+HzHD7P4fMcPs/h8xI+L+HzEj4v4fMSPi/h8xI+L+HzEj4v4fMSPi/h8xI+L+HzEj4v4fMSPi/h8xI+L+HzEj4v4fMSPi/h8xI+L+HzEj4v4fMSPi/h8xI+L+HzEj4v4fMSPi/h8xI+L+HzEj4v4fMSPi/h8xI+L+FzW4Ckto7XfL5Ig54a7WHUg4bT9PlFKSgHlaAaJEEaFBoSGhIaGhoaGhoaGhoaGhoaGhoaGhoaGhotNFpotNBoodFCo4VGC40WGi00Wmj00Oih0UOjh0YPjR4aPTR6aPTQ6KExQmOExgiNERojNEZojNAYoTFCY7iGLVy6KAXloBJUgyRIg1pQDwqNFBopNFJopNBIoZFCI4VGCo0UGik0cmjk0MihkUMjh0YOjRwaOTRyaOTQKKFRQqOERgmNEholNEpolNAooVFCo4ZGDY0aGjU0amjU0KihET6v4fMaPq/h8xo+t8VOLRuVoBokQRrUgnrQcDKfL0pBoaGhoaGhoaGhoaGhoaGh0UKjhUYLjRYaLTRaaLTQaKHRQqOFRg+NHho9NHpo9NDoodFDo4dGD40eGiM0RmiM0BihMUJjhMYIjREaIzSGa9jiqItSUA4qQTVIgjSoBfWg0EihkUIjhUYKjRQaKTRSaKTQSKGRQiOHRg6NHBo5NHJo5NDIoZFDI4dGDo0SGiU0SmiU0CihUUKjhEYJjRIaJTRqaNTQqKFRQ6OGRg2NGho1NGpo1NCQ0JDQCJ9L+FzC5xI+l/C5hM8lfC7hcwmfS/hcwucSPpfwuYTPJXwu4XMJn0v4XMLnEj6X8LmEzyV8LuFzCZ9L+FzC5xI+t8VWTYxSUA4qQTVIgjSoBfWg4TRCY4TGCI0RGiM0RmiM0BihMUJjuIYtwLooBeWgElSDnho9GWlQC+pBw8nejVuUgnJQCapBoTF93rNRC+pBw2n6/KIUlINKUA2SoNDIoZFDI4fG9HmvRikoB5WgGiRBGtSCetBwqqFRQ6OGRg2NGho1NGpo1NCooVFDQ0JDQkNCQ0JDQkNCQ0JDQkNCQ0JDQ0NDQ0NDQ0NDw95DtRFmr6IuakFTQ42Gk72WumhqdKMcVIKeGsNG0/T5RRr01BjNqAcNp+nzYVWmzy/KQWW+wvkwrKCACjawgyNw2t0xgRlEbaA2UBumZmc1GthBU5vNbau+HBOYwQJWUEAFG9hB1BJqCbVkavZS43pPdmEFBVSwgR0cgfbW7IUJRC2jllHLqGXUMmoZtYxaQa2gVlArqBXUCmoFtYJaQa2gVlGrqFXUKmoVtYpaRa2iVlGrqAlqgpqgJqgJaoKaoCaoCWqCmqKmqClqipqipqgpaoqaoqaoNdQaag21hlpDraHWUGuoNdQaah21jlpHraPWUeuoddQ6ah21jtpAbaA2UBuoDdQGagO1gdpAbYRafzzABGawgBUUUMEGdhC1hNrKkm6YwQJWUEAFG9jBEbiyZCFqGbWMWkYto5ZRy6hl1DJqBbWCWkGtoFZQK6gV1ApqBbWCWkWtolZRq6hV1CpqFbWKWkWtoiaoCWqCmqAmqAlqgpqgJqgJaoqaoqaoKWqKmqKmqClqipqi1lBrqDXUGmoNtYZaQ62h1lBrqHXUOmodtY5aR62j1lHrqHXUOmoDtYHaQG2gNlAbqA3UBmoDtRFq4/EAE5jBAlZQQAUb2EHUEmpkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJJBlgyyZJAlgywZZMkgSwZZMsiSQZYMsmSQJYMsGWTJIEsGWWIrBFNKhiPQsuTCBGawgBUUUMEGotZRG6hZlqRsmMECVlBABRvYwXFhtsWEjgnMYAErKKCCDewgagm1hFpCLaGWUEuoJdQSagm1hFpGLaOWUcuoZdQyahm1jFpGLaNWUCuoFdQKagW1glpBraBWUCuoVdQqahW1ilpFraJWUauoVdQqapYlqRomMIOm1gwrKKCCDezgCLQsuTCBGURNUVPUFDVFTVFT1BpqDbWGWkOtodZQa6g11BpqDbWOWketo9ZR66h11DpqHbWOWkdtoDZQG6gN1AZqA7WB2kBtoDZCLT0eYAIzWMAKCqhgAzuIWkItoZZQS6gl1BJqCbWEWkItoZZRy6hl1DJqGbWMWkYto5ZRy6gV1ApqBbWCWkGtoFZQK6gV1ApqFbWKWkWtolZRq6hV1CpqFbWKmqAmqAlqZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJElmSzJZEkmSzJZksmSTJZksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZUsiSQpYUsqSQJYUsKWRJIUsKWVLIkkKWFLKkkCWFLClkSSFLCllSyJJClthSzDR3Ks22FvNCy5ILE5jBAlZQQAUbiFpGraBmWZKTYQYLWEEBFWxgB0egZcmFqFXUKmoVtYpaRa2iVlGrqAlqgpqgJqgJaoKaoCaoCWqCmqKmqClqipqipqgpaoqaoqaoNdQaag21hlpDraHWUGuoNdQaah21jlpHraPWUeuoddQ6ah21jtpAbaA2UBuoDdQGagO1gdpAbYSaLe50TGAGC1hBAU2tGDawg6Y2d960ZZ6OCcxgASsooIIN7CBqGbWMWkYto5ZRy6hl1DJqGbWMWkGtoFZQK6gV1ApqBbWCWkGtoFZRq6hV1CpqFbWKWkWtolZRq6gJaoKaoCaoCWqCmqAmqAlqgpqipqgpaoqaoqaoKWqKmqKmqDXUGmoNtYZaQ62h1lBrqDXUGmodtY5aR62j1lHrqHXUOmodtY7aQG2gNlAbqA3UBmoDtYHaQG2EmjweYAIzWMAKCqhgAzuIGlkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImQJUKWCFkiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZImSJUqWKFmiZEkjSxpZsta95mFYwAoKqGADOzgCV5YsTCBqCbWEmmXJ/OxHXuteL2xgB0fg+lrMwgRmsIAVRC2jllHLqGXUCmoFtYJaQc2ypGRDARVsYAdHoGXJhQnMYAFRq6hV1CpqFbWKmqAmqAlqgpqgJqgJaoKaoCaoKWqKmqKmqClqipqipqgpaopaQ62h1lBrqDXUGmoNtYZaQ62h1lHrqHXUOmodtY5aR62j1lHrqA3UBmoDtYHaQG2gNlAbqA3URqitda8XJjCDBayggAo2sIOoJdQSagm1hFpCLaGWUEuoJdQSahm1jFpGLaOWUcuoZdQyahm1jFpBraBWUCuokSWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0s6WRJJ0s6WdLJkk6WdLKkkyWdLOlkSSdLOlnSyZJOlnSypJMlnSzpZEknSzpZ0smSTpZ0sqSTJZ0sGWTJIEsGWTLIkkGWDLJkkCWDLBlkySBLBlkyyJK17rVUwwJWUEAFG9jBEbiyZGECUcuoZdQyahm1jFpGLaNWUCuoFdQKagW1glpBraBWUCuoVdQqahW1ilpFraJWUauoVdQqaoKaoCaoCWqCmqAmqAlqgpqgpqgpaoqaoqaoKWqKmqKmqClqDbWGWkNtZYkaVlBAU+uGDezgCFxZsjCBGSxgBQVEraPWUeuoDdQGagO1gdpAbaA2UBuoDdSGq5W17vXCBGawgBUUUMEGdhC1hFpCLaGWUEuoJdQSagm1hFpCLaOWUcuoZdQyahm1jFpGLaOWUSuoFdQKagW1glpBraBWUCuoFdQqahW1ilpFraJWUauoVdQqahU1QU1QE9QENUFNUBPUBDVBTVBT1BQ1RU1RU9QUNUVNUVPUFLWGWkOtodZQa6g11BpqDbWGWkOto9ZR66h11DpqHbWOWketo9ZRG6gN1AZqA7WB2kBtoDZQG6iRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksWete56d9y1r3emEDp1othiPQsuTCBGawgBUUUMEGoiaorSxp/zAxgRksYAUFVLCBHRyBDbWGWkOtodZQa6g11BpqDbWGWketo9ZR66h11DpqHbWOWketozZQG6gN1AZqA7WB2kBtoDZQG6G21r1emMAMFrCCAirYwA6illBLqCXULEskG1ZQwKkmxbCBHbQxWSdallyYwAwWsIICKtjADqJWUCuoFdQKagW1glpBraBWUCuoVdQqahW1ilpFraJWUauoVdQqaoKaoCaoCWqCmqAmqAlqgpqgpqgpaoqaoqaoKWqKmqKmqClqDbWGWkOtodZQa6g11BpqDbWGWketo9ZR66h11DpqHbWOWketozZQG6gN1AZqA7WB2kBtoDZQG6G21r1emMAMFrCCAirYwA6itrIkGSYwgwWsoIAKNrCDIzCjllHLqGXUMmoZtYxaRi2jllErqBXUCmoFtYJaQa2gVlArqBXUKmoVtYpaRa2iVlGrqFXUKmoVNUFNUBPUBDVBTVAT1AQ1QU1QU9QUNUVNUVPUFDVFTVFT1BS1hlpDraHWUGuoNdQaag21hlpDraPWUeuoddQ6ah21jlpHraPWURuoDdQGagO1gdpAbaA2UBuojVBb614vnGrSDTNYwKmm6+8KqOBU02LYwRFoWXJhAjNYwAoKqCBqCbWEWkYto5ZRy6hl1DJqGbWMWkYto1ZQK6gV1ApqBbWCWkGtoFZQK6hV1CpqFbWKWkWtolZRq6hV1CpqgpqgJqgJaoKaoCaoCWqCmqCmqClqipqipqgpaoqaoqaoKWoNtYZaQ62h1lBrqDXUGmoNtYZaR62j1lHrqHXUOmodtY5aR62jNlAbqFmWzH2xy1r3emEFp1ozS1uWXNjAqdaG4XBc614vnGpzs8uy1r1eWMCp1puhgApOtVEMOzgCbVR3o1lgVMNZYIhhAzs4Am1QX5jADFpdOxobvhc2sIMj0IbvhQnMYAEriJqipqgpaopaQ62h1lBrqDXUGmoNtYZaQ62h1lHrqHXUOmodtY5aR62j1lHrqA3UBmoDtYHaQG2gNlAbqA3URqitpZYXJjCDBayggAo28KmW546nxZZaXjh/Ch0TmMEC1onVUEAFG2hqYjgCs6mpYQIzWMAKCqigqQ3DDo7A+VOY57ZJxZZaOmZwqiU73vlT6Ciggg3s4FQz+9tSS8cEZtDU7MhqBQWcatkaaqaGYwenWrZiMzUcE2h1s+Gsm63uzIdsF1e2fDIXO/SZD44JzGABKzjr2kylLZ90bGAHTc2OoT3AqVbtIGc+OBawggIqONWqDYKZD44jcOaDo6mZA3oGTc0OsldQQAWnmk1H2fJJxxE488ExgRmcamKHM/PBUUAFTc0OcnRwONryyedsr2ECM9hAqzDPwhY/Zrs+thWPz7lawwoKqGADZzFVwxFolr4wgRks4FSz33Zb8eioYAOnmv3M24rHC83SF061Zkdmlr6wgKZWDU1NDE3NWtIsfWEHR6BZ+sIEzrrdDtLMe6GCDezgCDQX9nn5YAsPHadEt+M1v9kVii0xdFSwgR0cgeYLu4SxpYAXmi8uTGAGC1hBARVsIGodtYHaQG2gNlAzB3QbqTbW+4wKW96X54bjxZb3OWZwVhjZsIICKtjAHmi+sEs5W7KX7QLOluxl+920JXuODbQKajgCzQwXJjCDBTS1biigqdnJmxku7IFz2Bf7PbZleOVh7TAHuKNVEMM2/6ud5hzgjiNwDnBHq2vtMH+zHAtoatY6VUAFUauoVdQENUlgjr4QelPoTaE3hd4UetM8tLrQfrNWF5qHVmcpvan0pnlo9YXSm0pvNnqz0ZuN3rTfrNVvjd6036zVWY3ebPRmf0QX9hL91ulN89vqwq7RUJ327bRvp33HIzpr0JuD3hwlOmvQm4PeHKgN1AZqw9WqLZe7MNlfUMMRmB+gHU43zGABKyiggg3s4Aicvwwl2eGYRS7MYAErKOBUS3a8ZpwLOzgCzThzE5Zqa84cM2hqdmRmnAsFNLVh2MAOjkAzztxjpdrqsjJ3jai2usxRQAVn3bmBRLXVZc+HXoaz7ryerLa6zDGBGTQ1O2OtoIAKmpqd2/TQ8wHZxOmhUuxwpodKscOZHirF/tn0kGMFBVSwgR00NWt1c9aFU62a8Px9cyxgBQVUcKpVawfz24Uj0Px2oanZ4ZjfLiygqdmRmd8uVNDUrLvNb2LHYH4ztCVljgnMYAFnXamGDeyByf5CM2yg/YVuOALNxxcm0ISH4RTWh2EFBVSwgT3QHKt26ObNecFZbQ3Xc0rDUMEGWgU7IfPmQvPmhQnMYAFNTQ0FNDVrEvPmhT3Qfr7U2sFcqNYO5sILrUIxbNFQ5sILR6C58MJZt1mTmAsvLGCNDjAXXqggaoqaotZQM0NeOP9Cs1Y3D12YQHOsSZiHLqyggAo2cB5OsyYxDy00D12YwAwWsIKzbrMuNLdcOBxt0ZRjAjNYwAoKqGADO4haQi2hllBLqCXUEmoJtYRaQi2hllHLqGXUMmoZtYxaRi2jllHLqBXUCmoFtYJaQa2gVlArqBXUCmoVtYpaRa2iVlGrqFXUKmoVtYqaoCaoCWqCmqAmqAlqgpqgJqgpaoqaoqaoKWqKmqKmqClqilpDraHWUGuoNdQaag21hlpDraHWUeuoddQ6ah21jlpHraPWUeuoDdQGagO1gdpAbaA2UCNLMlmSyZJClhSypJAlhSwpZEkhSwpZUsiSQpYUsqSQJWVliRpmsIDiiVhWgCxsYAcjdEt+gAnMYAEriFpGLaOWUcuoFdQKagW1glpBraBWUCuoFdQKahW1ilpFraJWUauoVdQqahW1ipqgJqgJaoKaoCaoCWqCmqAmqClqipqipqgpaoqaoqaoKWqKWkOtodZQa6g11BpqDbWGWkOtodZR66h11DpqHbWOWketo8ZlR+Gyo3DZUbjsKFx2FC47CpcdZaA2UBuoDdRGqNXHA0xgBgtYQQEVbGAHUUuoJdQSagm1hBpZUsmSSpZUsqSSJZUsqStLhmEGCzjV5hcqq62UclRwqs050morpRxHoGXJhQnM4FSbk6jVVko5CqhgAzs4Ai1LLkxgBlGrqFXULEu6tY5lyYUdHIGWJRcm0NTUsIAVNLVmqGADe6Clxpxlrbb6qXTrFsuHCxWcFYZ1i+XDhSPQ8mHOwFVb/eSYwQJOtWEnZPlwoYIt0JJgWPOZ5+dEWLUVTY4C2vGahHn+wg6OQPP8hQnMoKlZ65jnLxTQjtda0jx/YQeHo61ockxgBgtYQQEVbKCpDcOnWp3ziNVWNDkmMIMFrKCACjawg6hlUyuGCcygqSXDCgpoamLYwA5OtWTFpucdEzjV5kPYaiuaHCs41Wy2zlY0OTZwquVVbAROzztONZs0sxVNjgWcaja5ZSuaHBWcanOXgGormhxHoOQ4Y7HWsbqiYAM7OAL1Ac7jtQk2W6XkWEA7Xjt5FVBBO95VrIMjcHne/u7y/MIMWl0bqU3BBnZwBE7POyYwgwWsIGodtY5aR62jNlAbqA3UBmoDtYHaQG2gNlAboWbrkRwTmMECVlBABRvYQdQSagm1hFpCLaGWUEuoJdQSagm1jFpGLaOWUcuoZdQyahm1jFpGraBWUCuoFdQKagW1glpBraBWUKuoVdQqahW1ilpFraJWUauoVdQENUFNUBPUBDVBTVAT1AQ1QU1RU9QUNUVNUVPUFDVFTVFT1BpqDbWGWkOtoUaWKFmiZImSJUqWKFmiZImSJbqypBtWUEAFG9jBEbiyZGECp5o9RrDFYY4VNLVhqGADOzgc28qShQnMYAErKKCCU22+z1dtcZjjCLQsmStJqi0Oc8zgVLNHDrbgq87lOdUWfF1o+SBimMAMFrCCAs7jtUlqW/Dl2MERaPlgTxRswZdjBqeaPWewBV+OAk41e/pgC74cOzgCLR9sjt8WfFV7JmFLu6o9RrClXY4KNtDqdkOra2dhSdDscCwJbALedtFzLGAFp5rdiNkueo4N7OBUa3a8Zn+bTbK1X3Wucam29qvaTZut/ap2gWxrvxwVbGAHR6DZ/8KpZjc2tvbLscaQM89fqCAjtTFSGyPVPH9hAjNYQNQ6ah21jlpHzTzfrc3M8xcm0E7IWtI8f2EFBVSwgR0cjrbgyzGBGSygqQ1DARVsYAdHoHnebsRsyZhjBgs41exOzVaPOSo41ezC0FaPVbuFsdVjF1o+2M2VrR5zNDU7HMuHCysooIIN7OAItHy4MIGoFdQKagW1glpBraBWUKuoVdQqahW1ilpFraJWUauoVdQENUFNUBPUBDVBTVAT1AQ1QU1RU9QUNUVNUVPUFDVFbQaI2E2mLWa7cAaIYwLjd8j2y3OsoIAKNrCDI7A/wDLVkqFVWNjmf82GHRyB4wEmMIMF1IlmpxHtawvf1mnawjfHDBawTqyGAirYwI4EaukBJjCDBaygxDEkBRvYwRHHkB9gAlHD8wPPDzw/8PzA8wPP2752l3ChJQstWWjJUuIYCi1ZaEk8P/D8wPMDzw88P/D8wPO2oO4SrhWkJSstWem32kFaEs8PPD/w/MDzA88PPD/w/MDztq/ddQxCSyotqbSk0pJq5yaGFbRzU0MFG9hBU7NjWJ5fmMAMFrCCAio41ZId5PS8o10/WEv27C60JXky3w+otiTPUUAF6aFOD3V6aDDWB2N9JcFCRt+ghwY9NOihQQ8NRl+khtiSPMcEZtDOIhsq2EBrnWI4z2JOpYntVeeYwAwWsIICKtgCLQmSGCYwgwWsoIAKNrCDI7CgVlArqBXUCmoFtYJaQa2gVlCrqFXUKmoVtYpaRa2iVlGrqFXUBDVBTVAT1AQ1QU1QE9QENUFNUVPUFDVFTVFT1BQ1RU1RU9Qaag21hlpDraHWUGuoNdQaag21jlpHraPWUeuoddQ6ah21jlpHbaA2UBuoDdQGagO1gdpAbaA2Qs2WEDomMIMFrKCACjawg6gl1BJqCbWEWkItoZZQS6gl1BJqZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksyWRJJksyWZLJkkyWZLIkkyWZLMlkSSZLMlmSyZJMlmSyJJMlmSzJZEkmSzJZksmSTJZksiSTJZksyStL1FBABRvYwRG4smRhAjNYQNQKagW1glpBraBWUauoVdQqajYr8bDTtFmJCxVsYAdH4MqSbpjADJraMJznNt9cEFtg6ahgAzs4Ai1LLkxgBguIms1K2EWvLbB0bOA8N7tktQWWF9q05oX2XDobZrCAFRRQwQZ2cATarMSFqHXULDXyQmsdOzLLh2x9YflwYQIzaBWaoVWwHjLPG9pCSMcEZrCAs33nOyBiCyEdFWxgB0egef7CBJqaGhawggL6c3+xNZGOHTS12Wa2JtIxgRksYAUFVLCBHUStoFZQK6gV1ApqBbWCWkGtoGaet960NZGOCcygqRVDjS60K4ULO2hnMQeXrX50TKCdhRgyHpa7FwqImqAmqAmjTxl9yuhTRp+ipkjYhUCx7rYLgYV2IXChHbr9XbsQuLCAFbQOGIYKNrCDU63aoLWf/PngT2wZo2MFZ91q/WY/+Rc2sIMj0Cx9YQJNzXrTfvIvrKCACjawg8PRVinKfN9JbD2izDebxNYjOnZwBJqPL0ygHWQ3LGAFBVSwgR0cgebj+R6V2HpExwwWsIICqneLrUd07OAIXOZthjVax2x6oYINnMXmFLPYwsKrScyQFxZw1hVTswv6CxWcdedGA2ILC/2f0QFCBwhqgpqgZja9UEC6W+huQU2RsDXI8/GPrDWGF9qh2zCy6/ULG9jBEWg2vTCB89DFWtJsemEFTc0Ox2x6YQNNzY7MbLrQrtcvTNcaQ7Ed1hwLWEEBFWxgB0egrUe8sFzrMmWtPLzQzsIGl9n0wgZ2cDjaykPHBFqbDcMCVnCqzcfkYisPHRtoat1wBJq7L0zX4lGxlYeOBayggAo2sIMj0FYbXzjPYj61F1tj6CignUU2bGAH51nMB/hiawwdZ5vNtwPF1hg6FtDUxFBABRvYwRFov8cXmpoaZrCAFRRQwdlmak1iK4jXya+3Eazf1tsICwtYQQEVbODsi9XH671Fw/Xe4sIETrXVvpYEF1ZQQAUb2MERaCsPL7TWsVFtnr9QQGsdOxzz/IUdtL6wNjPPXzj7Yp2x/WBfWMCp1qx97Qf7QgUb2MERaD/YF5qanZD9YF9YwAoKqOBss/l0UnRtlFEMZ188FmawgBUUUMEGzr6YjyfE1hheaG8YXJjAfO29ILbG0LGCAirYwA6OwLWpxsLoec0VFDB6XnMDOxg9r+UBRs/bakLHAkbP22pCRwUb2MHoeVtN6Bg9b6sJHQtYQQEVpOeFnhd6Xuh5oeeFnhd6Xuh5oeeFnhd6Xul5peeVnld6Xul5peeVnld6Xul5pecbPW+eb3Zk5vkLBVTQ+mL9sw6OQPP8henabEZ0bYOzsIAVFFDBBnZwBC532/Bc7l5YQQEVbOA8i27dbb/zhrYW0DGBU20uthJbC+hYwak2112JrQV0bKCpiaGpzZ8ZWwso8y0SsbWAjhksYAUl0C7H7crGFgA62j8bhhWc/2w8DGdT2wTF2vHtwg6OQNse6sIEzrrDWsdsOqwdbMsnu0Vcu7gttC2fLrQKdui2i9uFBayggAqamjWqXZlfOBvVRrUt9XNMoB2vHbrtcmOTGbZ872oSuyleaBfeFyZwtu+wf2Y3xRdWkPa1y/ELG4iaomYuHNY65sILBXwW04e173ShYwdH4HShYwLzRDvI6ULHCgpoatbUvYEdNDUbUfOXV22mzNbsOWawgBUUUMEGdnCq2YyhrdlzNLVqmMECVtDUmqGCDezgCEwPMIEZNLVuWEHrt2Foagsb2MERmB/glJgb04gt1HOs4Dwhm2W1hXqODZwS2Rpq+vjC6WO1CUxbqOeYQVMTwwoKqGADOzgCq6mpYQIzWMAKCmhq2XB42PTlbvsLy90LM1jACgqoYPNwtCV5jiPQkuDC5CnXVxIsLGAFBVSwgR0cgc1axwZXK2AFBVRw9oVN5NriO8cRaKFwYQIzONVsotF2qHMUUEFTsz62ULhwBFoo2CygLdRzzKCpmVssFGxmzz5WqzazZ8v3HBvYweFoi/oc50VZMapBEqRBLag7mStt+slW1V1orrxwXpktykElqAZJkAZZxdnFtkZObeZvrDfsjGqQBNkDIaMW1IOGky2OW5SCTKQaFnC2tU2V2dI4RwXtMGcX2XI3nXsoiS13c7TpGSMr0A0VbGAHR6Bd6drpaTSnRnNqNKdGc2o0p/ZoxDlrdTWiWcamGG3tmuM8VZsKtLVrjvNIbXpvrV1b/7EHDSe7lF2UgnKQVbQDMQPY9NlYv4qTbPwvSkGWGEYlqAZJkAa1IBOxLrRxP1FtWZrOiTm1ZWmOGbTDVEOr0AxH4Lr4NEpXw6itP3MsYAWt7PpnCjawXw2utm/dheakC1HLqGXUMmoZtYxaRi2jllErqBXUCmoFtYKa/dRdqGuoqy1Ks+GrtijNcQTaL92FKXD+OKnaIZiZLizgHOPWU3bbuEiDWlAPGk5rlsgoBeWgEhQaGhoaGhoaGhrz10jnjJDaEjHHBNrJ2BA0w104G1Gt5cxwFyrYwA6OQPuNutDUbIzab9SFBTQ1O14z44UKmpr1g1n0whG4Xls3SkE5qATVIAmyinNs2IIvnZMZagu+dE5FqC34cqyggPNI52212oIvxw6OQLsMvXAeqhqZWDUsYAVNbP1dBRtoYt1wBJpLm52aufTCDNq7XkY1SII0qAV1J3Nit8Yyz3VrC/PcvIlWW73l2MAOziPtdoJmugsTmMEC2hpgIwnSIHt5x6gHDSdbDb4oBeUgExHDCgrYA9UO01pCMzgbtBnVIAmyFjEpbWAHZ4sMa1Oz64VTaljzml0vnAc7rCHNrsMGldl1WDuZXYcdrNn1wg7abM+kNdljlIKsqJ2V+W+s/2r/3A7W/Des0af/2sMOdhqwPewIp9vaw45w2s1RQWsEox40LrJ1Um1OtKmtiGpzHk1tRdSc1FdbEHVRn/+zGI6J9l/TA0xgBsvEZlhBARVsYAdHYH6AVtfOIVuF2Ua2hKnNRfVqS5jaXB2vtoTJsYAVbIHVKmTDBFoFa6bph5asmcT+rjWJJDCDpmbtIBUUUKOuNP5rB0egPsAUZ6wZLGAFOTftcUI6Ahtn3EqMhmbHa03d7HitqZuCDezgCOwPMIHWOnZkvYAVnGrZunD+OrVshz7d0bId5HRHy3aQfcSQXe5YmMBZNy8UUEG7UjHqQeMiW1HU5r252tqhNm+y1dYO2Q+7LR26yA6qGc6DmjN3aiuHHBOYwdkE8+MIaiuHHAVUsIEdHIHmjgtn3XmfqrYaqM3bAbXFPq3Y8ZoP5m2c2rIeRwEVNGGjHjSczDCLUlAOKkE1SII0KDRqaNTQkNCQ0JDQkNCQ0JDQkNCQ0JDQkNDQ0NDQ0NDQ0DA/WcuanRYNJzPTohSUg0pQDZIgDQqNFhotNHpo9NDoodFDo4dGD40eGj00emj00BihMUJjhMZwDdslrNWFNnjUcKrMe3K19Tdt3oKqLY5p875abXGMYwKngF342OKY+V642tqYiyRIg1pQDxpONuAXpaAcFBolNGys24WEbbrV7JrF1sbYdZEtjbmoBNUgCdKgFtSDhtMc2ReFhoSGhIaEhoSGhIaEhoTGHNl2FWVrYi5KQVPDWnqO7ItqkLXCTBJb+NLsttAWvjS71bOFL44FrKCACjawgyPQhvaFqHXUOmo2vMVGlo3vCxVsYAdHoA3yCxOYwQKiNlAbqA3UBmoj1Gw5jF2B2mqYi3JQCapBEmQVZxrb4pZm8xm2uMWuU21ty0U16Pmv7drWFrZc1IJ60HCarrzITlwN7RSbYQM7aKdoh7n8tjCBGSxgBQVUsIEdRK2iZj89Nkdgq1ccCzjV7KfaVq84TjW1ZrUfIPvVtx2yml302g5ZF9pv0IWmZsL2K3ShqQ3DqWYBub7591ioYAM7OALto2kXzrp2E2zrVJr9DNk6lWY3rrZOxXEEmnEt1GyHLMcMFrCCVtdO08zYrI/NjHa/aytSHAtYQQEVbGAHR6CZ0e6YbUWKYwanmt0L24oURwEVnGp2s2x7YTkOx/VtPrtGXN/muzCDZWIxrKCACjawg9abs1FtnYpjAue52V26rVNxrKCAPdB+MLtJ2A/mhVbBDt1+MS8U0I63GzawgyPQvt15YQIzWMAKCohaQa2gVlCrqFXUKmoVtYpaRa2iVlGrqFXUBDVBzXxsP422TsWxgjKxGSrYQOuhYTgC7arSJhBsnYpjBgtYwalmkw22TsVxqtm8g61TaTbDYOtUms0h2DoVxwSamh2kef7CCj7Vkt0iro8fXtjADo5A+/jhhVbXWtI8bzMWtiKlW4jZihTHETg97zh/E23GwtapOBawggLa8S6047UTGqZmDTVMbbaDrVNxnCPK7izXRwrnYzq1VSZpLqLWtr7yvTCBdmQLC1hBARVsYAfnkdlche1O5ZjAEke2Pu29UEA7dDuh9WnvhR00iTl2bEWKYwLnCdlchW1J5ThPyKY4bEsqRwVNrRt2cASuT3svTGAGC1hBARVEraJWURPUBDVBTVAT1AQ1QU1QE9QENUXNrqdtSsZWujgW0FrSulsFVHAOjbSKdXAEtgdoasNwqtkkiS2FSXavZUthHAWcamusT0s7dnAETks7JjCDBayggKh11Dpq9j1Tu2O0pTCOCcxgASsooIKz36qNavue6YXD0ZbCdJtCsqUwjhksoJ3b+mcCKjgCLRRsksiWt3SbJLLlLY4CKmgVZsfa6pVuEze2esWxggIq2MDZvjbJY6tXLjTPX5jADBawggKaWjNsYAdHYDU1az67X77Q1Kyh7I75wgrO3rSHWH19gnthAzs4AtcnuBda3Wo4j9eeytk6lW4xaOtUHEeg3RZfaMdrfWE+vrCAFRTQbsDtGMzHF3ZwBJqPL0yg3erb8bYCVlBAU7PjNR9f2EFTsyMzH9sNvK1ecZxqdi9vq1ccp5rdUtvqFUcFG9jBEWg/4xcmMIMFRG2gNlAbqA3URqjZ6hXHBGawgBUUUMEGdhC1hFpCLaGWUEuoJdQSagm1hFpCLaOWUcuoZdQyahk1ywebcLAtqRw7OALtMt8uLW1LKscMFrCCAirYwB5oSSAL7XiroYB2vGLYwA6OQJssuzCBGbS6akj7Cme8psIWJjCD1r7NsIICKkhvKmpKbzZ6s9Gbjd5s9KZ5fh2Def5CerPRm+b5dQzm+YXm+QtR66h11PD8wPMDzw88Pzpjp9OSg5YctOTyvB3DoCUHLYnnB54feH7g+RGeb4/wfHuE59sjPP/Ech3DEysooIINNLVuOAKX54dhAjNYQJs0tWLm+QsVbGAHR6B5/sIE2gRtMSygD/Bma3v6nLBqtrbHsYMjsPjQaLa2xzGDBayggAq2aPXSQTqr0lmVzqp0Vi1gBQW0sxDDEWj2v9AaytrB7K92ZHYhcGEFBVSwgR0cgRYVF1pdGxprjnyhgApaXRsaFgoXjkALhQvtssNOyELhwgJWUEAFG9gD16W7Hc66dF9YwArOunOqsj3WRbodmRl9oRn9wlm3WQ+Z0S8s4KzbbPwO4Z8p2EDURqilxwNMYAYLWEEBQ8LWAdlFerN1QI4ZtEOvhhW0JlFDBRs4D31OjDZbCHSh+fhCayg7BvPxhQWs4FSbs5bN1gI5NrCDU21OYDbb4qnPCcFmWzw5VtDq2mmaeS9sYAdHoJn3wgSamrWOmffCCgqoYAM7OALNsd0a1bzZrfnMmxd2cASaNy9MoB2kNao59sIKCqhgAzs4As2xwzrAHHthBgtYQQE1usUce2EHR6CZd06JN1sddLWO2fRCBRs4iw0bGoMmMZteWEA7SFMzm16o4Kw7rOcHHTCiA/LjASYwgwWsoIAKNjDUbGWRo8/WNVtD5CjgvAw1S9saIscOzkOfs6HN1hA5JtB609TMphdW0NTW31WwgR0cgXaJfWECM1jACqJWUCuoFdQKahW1ilpFraJWUauoVdQqahW1ipr9Hs9J32bLnxwzOJ9KzundZsufHG3IDUMFG2iPJrPhCFR7OFkNEzgfgc7HKc2WPzlW0M7N6qqCDezgCGwP0OraGTd7kGrjodmTVDvN1sER2B/gPN5kJ98zWMAKCjjVko3faXTHDo7A+SvtmEBTs+MdBayggKZmxzsa2MGpNuccm+2/NMx6tv+S41Sb82fN9l9ynGrmQltD5ahgAzs4AtMDTGAGC4haQi2hllBLqCXUMmoZtYxaRi2jllHLqGXUMmoZtYJaQa2gVlArqBXUCmoFtYJaQa2iVlGrplYNC1hBAaeH7C7Jlmw5dnAE2hTdhQnMYAEraGcxzWtrsoaFjS3KcrTjbYYFrKCACjawBzara8KN9m2csXn+wgZ20Np3RoWtzHJMYAbpzY5apzc7vdnpzU5vdnpz0Jvm+XU4g94c9OagNwfnZp4vZmnz/IVTrZilzfOG9u1IxwROtTn32mxXJscKCqhgAzs4As3zdjdjezU5Fu8s26BpzNnbZhs0OSrYwO4dUFN0Vs0PMIEZLGAFo7MqRq8YvWL0itErRq8YvWL0itFtr6Yxnzg2W4/m2EFrKGsHs3SxIzNLX5jBAlZQQAUb2AOnecd8yNJsaZpjASs461YbGvPH3bGBHbQfSzuh9eO+MIEZLGAFBVSwBdrP+Hw83Gz1mmMGZwQlG3L29OxCAe0sFjawg/ZA3PptPRBfmEBrMxu/Zv8LKyjXg+tmq9ccG9jBEWhPzy5MYAYLWEHUBmoDtYHaCDVbveaYwAwWsIICKtjADs7xMB9lNNvMyTGB9vi9GhbQWtIqWBJcqKBd7D0MOzgC8wNMYAatbje0nh+G83jF/oK5+8IEZnD2vM052sI3RwEVbOBUm9PnzRa+XWiev9Cedy/MYAHtebcVW0/XFyrYwA6OwPV0fWECM1hA1AQ1SwKxzrIkmJP1zRa+OY5AS4ILE5jBAlZQQAVRs598u8CwRXIXtgdoajbOWgYLaGrW83Z5cKGCI7DbM2w7417ACgqoYAPtGYodunl+oXn+wnm8Nldsi+QcCziPV2302U/+hQpazyfDDg7HtUjuwgRm0NSKYQUFNDU1bGAHZ5vZJLUtknNMoJ1bMyxgBU1tduH68mM2ykHzH7WFFRRQwQZ2cB6iTfzZujjHBGbQ1Oy4zOYXCmhqdrRm8ws7aGpzENm6OMcEZnCq2cygrYsbNoFkK+CGTdvZCjjHETgN7TjrzgVuzVbADZtLshVwo9vh2E+7TYPZCjhHBRs41WzCy1bAXWiGvjCBU80mm2zZ27DJJlv2Nob1u7nY5mZs2duwqQFb9uY4As3FFyYwgwW0BYQ2E7HWvTm3GFH2437hCLRr+wsTyPA0oz9sssI2awqWjdcSYDvZ3jbuGw94PDZOG+eNy8Z1Y9l40x2b7li61sxjBLe1PPbitHHeuGxsujZt0dYa2Yt147ax6c61g22turt4LZS92HTtGsoW3j25GpeNl64Yy8ZL144ttY37xgPOj43TxnnjsnHdWDbedPOmmzfdvOmWTbdsumXTLZtu2XTLpls23bLplk23bLp1062bbt1066ZbN9266dZNt266ddOtm65surLpyqYrm65surLpyqYrm65surLp6qarm64u3WZcNq4by8ZT18LXVu45dnAE2r3HhQnMYAEruE5npm9bmbNwHbX9lZ43LhvXjWVj3bjBK13sEncttbtaZWxnP7azXylycdvYWt0mAdeCu8V9pcjFaWN6uz/KxnVj2Vg3bhv3jUccT79SZHHaOG9cOJ6VIhfLxpvuliJ9S5G+pUjfUqRvKdK3FOmZUdZz3Vg21o0bx5P7xls7bynStxTpW4r0LUX6liJ9S5G+pUgv9G+/UmTx1s51a+e69e9KkYu3dt5SpG8p0rcU6VuK9C1F+pYifUuRvqVIl61/ZWtn2dpZtnaWrZ1XitiUdV8pcvFq5/kr1FeKXJw2zhuv87XjWSlysWysG7eN+8YDbo+Nl64dc8sbW5jYITQNW/eVJjZlZksFgwfcHxtv3di3buxbN/bNLn2zy4qZi7dh27du7Fs3jq0bx9aNYxu2Wyz1sQ2fsQ2fsQ2fK35mvI0rfhanja2+zXWO6zWfZFw3lo1147Zx33jAK34uThvHDaQtD3RUsIEdjNvKsQLGbuzHCpiL88brjKrxOiM1lo1147Zx33jAK2AuThvnjcvGm64FjM1mrNWCFzbQHh7YsVu4LLRsudAeHlgTWrJcWMAKCqhgAzs4AtejioWoCWorNmz2dax4sLnRseLB5j7HioeL08Z5Y6tjt6Zj2b3aOS67L152vzhtnDcuG1tr21ziWLc0F+vGbeO+8YBXDlycNl661g4rBy6uG8vGtozbDs1i4MIOLlFrzBUCF6eN88Zl47qxbKwbt437xqHbH4/HxmnjvHHZuG4sG+vGbeO+8fBO748VDhenjfPGS7cbq3d0f6xrkIv7xqv+mLwi4uK0sdWfk5H9kQv/dkXExbLxpps33bzp5gGXx8Zp47zxpls2rXV9MY3WH+v6YvG6vrjYaor9/XV9cXHZuG5s9eekY3+s64uL28Z946Urk9d1xJz16491HXFx3XjVt/5d1xEXt437xgNeQXFx2njpWr+v64iL68aysW7cNu4bD3iFhtoYWOGg1rYrHC7uGw94hcPFaWM7ZrU2X+Fwcd1YNtaN28Z94wGvfFDro5UPF+eNy8Z1Y9lY6buVDxf3jUdwWpkwf6F6Wt63dkvL+xfrxm3jdS5zLKVEW6Xl8YvLxqu+6a77j4t141W/Gfft39JHKT823nTzpps33eX9i2Vj3bhtvOmWTWv5et6n9rR++i+WjXXjVXMY940HvLx/sT0CWpjBAlZQQAUb2APXvUOzPluev7hsXDe282l2zsvzF7eN+8bjehW2p/Ue8MIEZrCAFRRQQWunZmNzXSxcnDbOG5eN68bruKfP0vL3XADb0/J3s/G7/H1x2XjVsbG5/H3xahcbp8vfF/eN1/HbWFj+vjhtnDcuG9eNZeOla+2z/H1x33gE5/X7f3HaOF+v1Pe8rN4W68ZtYys/5+B7Xj/zi9fP/MVp47yxndZcztvXukZn2Vg3Nt11bCsCLh7wioA5o9/zioCL88ZLV43rxrLx0s3GS7cZL91uvHSt2a4dAxanja3+sPNdcXCxbtw2tvrDznf95NuQXGsYncvGdWPdeFzbWPS1S9uFCczX5hZ97dJ2YQUFVLCBHRyBZvQL7TiHteH6Cb9YNtaNVztYP66f8IsHvOx+cbp2A+l5beuxsIAVFFDBBnZwBK6dd6zB1s47C9fJWEMv71+sG7eN18nY4FveX7y8f3HaOG9cNq7XpjN97eZ2oYIN7OBwtIWLjgnMYAHX2ahx27hvPOBl+WH/dln+4rxx2djOphoKqGADOzgCbRetCxO4eqcby8a6cdu4bzzg9dKQUQrKQSWoBkmQvRBj1IJ60HCytw0WpaB1/MPYForMJ3R9LTJ0HrD5WxYmMIMFrKCACjawgyNQUVPUFDVFTVFT1BQ1RW2tVJp7evaylipdnDcuG9sam/lUsZe1XOli3bht3Dce8FqzdHHaeOkW47Jx3Vg2Xro2AtfSpYv7xgNeq5dWD67lSxfnjcvGdWPZWDfeRstgtNS1YGmuB+91rVi6uGy86qvxqt+MdeO2cd94ndd0jS1cDE4b541NN9mx2Q+/LUbrtpAxWDduG/eNB2w//M5p47xx2XjTtVeQkpEGtSB7UctoOFk2LJq+tTOxbFhUgmqQBGlQC+pBw8myYVFo1NCoq62K8WoT68eVDMn6UR4bp43zxquO9YusOsN4wPrYOG2cNy4bW9tmaz37sXfWjdvGfeMBX6sXF6eNl66NvZUJF9eNZeOla/21MuHipVuNl661ycqEi9PGeeOycd1YNtaN28Z9403XFjTbEdvipkU5yFalGNUgCbKVRkYtqAeNi2wd40UpKAeVoBokQRrkGrL8Pp/BdFm+ng8Zuixfz4cMXZavL9aNG7z8O9fLdVk+ndP5XZZPL5aNdeO2cd94LU2dvrAVisFp47xx2bhuLBvrxks3GfeNB1wfGy9da7eaN1661m61biwb68Zt477xgJf3LzZdm1td6xady8Z1Y9lYN24b943XQ62J10IDwwRmsIAVXJWt15br5yrALsv1F89rDJsUXlv3XVhBARVsYAdHoG3zd+FqEOvcZepqHbRMfbFu3DbuGw94/dBfvE7HzLJ+6C8uG9eNl64d2/qhv7ht3DcewWvxonPaeOkOY9O1C7C1y5+zbKwbt437xiO6ae3155w2zhuXjevGsrFu3OAtKHT90F+cNy4br/NKxgSFbkGhV1AYr6Cwic+1+Z9z3ni12/r7dfu3srFuvOmWTbdsuldQLE4b543Lxptu3bRWCNit0NrrzzltvM5FjcvGdWPZeI2BZtw27hsPeF0w2KS7rgsDsfG2Lgwulo2tvk0e64qCi/vGA14RcXHaOG9sujZBuxY9OsvGunHbuG884HVhcPGqaW2+csAm2tdSRucBrxy4OG2cN17HbG2+cuBi2Vg3bhv3jUfwWsrovHSbcd64bFw3lo114xZ9164cWDzglQMXr/EmxhLttpYpOreN+8brXOZYWssRV1ut5YjOdeNV33TXRcLFbeP10sXDmD5ayxGd08abbtl0y6a7vH+xbtw27htvunXTWr62C/JWZWPduG28zmWOySZcnDfJG5eN18sp2Vg21o3X+ynW/ttNQdtuCtp2U9C2m4K23RS07aZgLSl0lo1147bxpts2reVrm+VcywadZeN1Ljbml68v7hsPePnaZi3XQkPnvHHZeOla+1/vKdmxXS8qLR7w8r7duK2d/pzzxmXjurFsrBubrt2irgWIziN4LUB0ThvnjcvGdeNVc46BtYgwzS0r+lpE6Fw2rhvLxrrxOmY17hsPeP2+X5w2zhuXjevGS7cZ68Zt477xgJf3L07Rd2sRoXPZuG68xpsYD9pt/aZfnDbOG69z6cZbWy2PX9w3XvVNd/2+X5w2tvr2RGEtBLz+rWx9JFsfyaYrm65susv7i5f3L97Ghm5jQzdd3bSWr+0Jx1rkl2z2fy3yc04b541l41XH2nB5efHysk28r1V79r5QX6vwkt20rlV4Fy9vXrx0bQwsb15cNq7UX968/rtu3DbuG8+7DrsXtMV5jgnMIOe6VuCt81sr8Jxpg7E+sCKG69C78Tr0YVw3lo1147Zx33jA1/uCD+O0cd64GNupmEWzzauuZXjZ5kzXMrxs86G2DM++L9NtFZ7jCLQv8Y2Fq7ad69o05LH+u2ysG7eN+8YDXluHXLzOqRnnjcvGS9faeO0f8rC2WRuI2NzmWnaXk7XBtLB93qqvb2YunAZ2LNdnv/qI74L1Ed8F6/bRzGc1azlpG9sZpfV3BmwmdbYzshm/tRzPuWxsZ2QXFWuZnrNu3DbuG5uuzc6t5XvOaeO8cdm4biwb68arvo0g+76f5f1adZezNUPXjdvGdpg2ybcW3l081mFa84y0cd54HaZpjbqxbKwbt437xsN5rIV39l3ysRbeOeeNy8Z1Y9lYr2YYa32dfSx9rPV1zmnjvPEqP4zrxrKxbtyuT++N9aXOC0egfQPwwgRmsIAVtOaa839jratzHvDaQOhiO59i/3ZtIXRx2bhuLNenFoft3+fYwA6OQPtO4IUJzKC105xeGGttnXPbeJ1PMR6wPDZe51ON88brfMS4biwbL13r/5UGF/eNB7zS4OK0cd546drwWmlwsWysG7eN+8azLcXQviUo1iL2LUGxAbi+tbtQQAUb2MERaJ/+FOsN+/TnhRksoKlZi6/v8C5UsIEdHIH2ed4LE5jBWbfaaa48KHaUKw8u7huP4LTy4OK0cd54dcwwrhvLxrrxPKE5mzrWF0IvHIH2hdALE5jBAlZQQDuduah7rDV4F69rg4vtdOai6LHW4DmXje10rOnWGjxnO52ltXLi4r7x0p2eWevxnNPGeeOycd1YNl66Ytw27hsPeF03XJw2trZshjE4UmVwpNo27htvg0O2wSHb4JBtcMg2OGQbHLINDtkGhzA4hMEhDA5lcCiDQxkcyuBQBoeuwfHf//0Pv/31X//lT//xl3/92z/9x9///Off/vG/4j/8+2//+L/+67d/+9Pf//y3//jtH//2n3/96z/89v/701//0/7Sv//bn/5mf/7Hn/7+/F+fQ+jPf/s/zz+fBf/vX/7650n//Q/868frf/rshO7//DmqngflJZ6W+aFIel3E9gK0Es+LTAq08kOBfDgKe5F3HcQzN1+WOJ3IczREjWePPl6eSH1dpM4RaSXqdhTtx9aU1/++zIkp+/dlZA5A9PZZFPthW2dRynjdHe11kXmXc7UD/76Wu//8eRLekEX7dhrpx3YYhxJFoh2EAqp3C2jyQfl8UhAFyuPHAukwJp8BEuNaUn9dI59aYl6IXi3Ryssap8a0/cZXiedd7cvGTIdR+bzEdn89L4e2IfE02w815NMeOZ7IoMKjvz6RQ43nI03vkydSQ8aPJfqpW+eN9dWtkl+WOIwtW9ZpFfqeVlJvV+jVT+M5p/OyQj6MzvyIyHzeARM1Nf9Y4jA4bRfpdRCjvT6IcuhSe9a6uvTZmAxvLe/1R3vdH6dRYd+nXqPi+VzkVYlpxZfNWbtn3vM3LL0s0T7u0/55n45P+7QcfkCGraZev8XPi3H6NI/7J2LfsLpORNKrEymHwZl7/IQ8XhY4R8XQGBTbz9iXHi318/Q+1ag2q7KuCLK+/i0sevwlymGRrTWe010/1jg1R/ce0YdsFR73B0ZJMTBKk5cDoxyG53Nqzsfncz5uD4wfj6MejiPbx+bX4Ho+pYwav9Inzc3+vF5rL/ukni447Zsiq0+e1+NbjS/Xiof4fN5adLKvyv6b2H6sUj8fHVU+HR3nc9GHxmGojNfn0k7B0UjA7WLnGSg/1ugfj4/xeQSe22NULh/Hfsn0pT0knX5g2yN+YNveHl9qnJLUPnp6tUdntJf+4/iQcnJM/NDXvI3T39U4pWmOAVJyfryuIacL2eJp+pxaLq9r6PGGNZz7QyL3+wPkZhRK/zwKZXw61M8dO7wxatli7GuD6mmQaunxM1lfDw7Nn3eslo879tgcI26Unpelr8eoyjc0h35Dc7TPm+N4ERa2z70dDuMwRsXeBFzXYWn7efqdZU/HYVs8XleDj9fH0Q6jVDWOY34l9WWNY6g/Lwi9yHNmbr/C/hLI7VBFc7hWS9bXNU6XMPZqyxqoKef3ajQug/p2lf67Gnq6FY5fubmdGK2avswLHAbq3OLYa0iW1zUOaVrw7ZZiz2dwP1Y4ZWkaWG67ifxaox8uTSX7z4KUx3sVRlyIJXl9HqfRVYr36nMa7vUI7eV071TjRFTfrGHfkb/uv1p+r0bnxr4/Xtc4e7Y9enj2OXXz+kg+vn06HkdLMZGX5ldXXh/HOE1S2xcOr8nZ3h4vfvPHxzdQx+Rgvr6O7Ri+nsnInyfHKJ8nx6ifJseQz5Nj6KfJcaxwKznOI7TzJGfuSPW6X8enTjmNLrEPKV1XDLm+5/r5Zpyfy3w762UVewf1ZdcW7p32ae+cvsz1PsqnfjsfR43HGc+rusfL4zjOWLQY6WnU/nLGwl5MfXkgUkbMk/6Q6l+LtFN8xLxa7T8U0ftFnk8awzJ1f8z1uyLj87kTe4H2sxH/k2btMUQ0pzf7RgtFTn2TTndAtinHlYc/zOLUXzmSzvV6lsORyOlJ5ojf7frDeP1yJElPT60iS0rp7b0it9vk/Jzj7lAbf+hQKw8ezj76mzFQHvHQ5vkMqL0ucnr+lEaOdn3yGC+T8XQk9urT1cEn5+TT81HbLOiadvzhyuzL84Z8GK9N42zm5tDvFZnv2cVTpB/uyb4Wad8w1E7PcG4OtaOD63bFmw7mOz12eM6EVJ7M6aFIOv72RZa0tnfwlxY5PpK6+Tt+jKN4MPak9qb5Sswcluf83esi5ePH+efjqHEF/5zzKofjOM5SMaNSyj7gyy8Usa/vrJ559MehyGlSt8Vk12jbTc3Xm4l0ejg1mkSNbTa15F85jsZxbM9Afn8cx2xt4ZrHPuv2uyM5rTFIkWh5n7H/nWuOj6eeT063+2+VV745PZ/K8pAIAamHI9HjKBmMknZo2Pb5bWs6PaK6e99qr45/duNqb41/eueaTs+o7t26nkvcunc9/4RLTBU9r4MPP5ynR1TPERIJ/9h+sL6uRTk9oipMjTxer8BIcpz9T7EYJbe6mffLj6+cMvFhH0VdvntyefmE6RitObMmpaZDPst33Gbp57dZxxjpsTzzeV9SXsfI6VHV/RWWx2MpiV/PZ0QfjuU06pWYb+Pwm3V6YHU70k5PrG5H2umR1c1I0/4NkXZ8ZnUv0o4l7kXa8cpXYw3U89LzcOXb8nEdAqNVxnZf8qVf2nEGq2y+yYcjOa66SayE2hc3f12E2uTzhD49s7qZ0K19Q0Kfnln9QkIfgyTHA5/yQ7t+DZLTc6f9gXPZn7B+tW9P3xAkPX9DkJweHN0Mkl6/IUi6fBwkxxI3g6QdZ49jFlvG4faon+YDavYDEdna43f2PT6+umnf0+Orm/Yd6RvsO/K32Pe4TFWUR60vFx4f79MqTzhrK+NlApym5FlYX/d7tN8tzh/HWcGYvCrPAfn6GvxYxF76vuKs5EOR71jk/w2r/D9f5v/4hnX+j88X+j++Y6X/7V45LPW/PTz2l81+aYylWBpV8mGWNT/Os6y33g+yjQteHsnNJebn0xGN2fjTpHE+PcVqLZ7ZzK/7vcz3c5GevWHnZ9QORfLH5s2nx1j3zHsscfcdHfncvKeHTzfNe/qNuWve+73SDr1yGh4jnlC2sS+8/zo88ulS9earOqe3p2727enp1e0XsMrHfXua97r9us6xyM31zPn0CtXdBc359Ojq3jOWn2RQLBad3/F7L8h6GgRIe32zmk838M+O5KnTdlP1u6csx3BnSXIZ7fVFVS7fEKnl80gtn0dq+YZILZ9HavmOSC2fR+pPhkdMEtXHD5NEXxrk9NTq7vCo6ePhUT9P5dO6r7vD4/TE6ubw+Mnk7r3hcbtX3h4ezIQ8Hv29y+VqHzy9itTTGDtNiN57dTvLN4xT+XycyufjVL5hnMrn41S+Y5zK5+P0J6Pj1jTIaSLlEa+XPa8+Xm8vkE8PqtR+N9ZsWy2Hn/3Tg6qRhGmhx8tf/Z+0R6M9+ptteve1+NM4rdGqz+iur2vUz117fkZ1y7WnEjdde3o+dde1pwdUN117erZ027W3e+Xg2uPoYIlm3ifaf6mGxKThMzFfvqefT8+nns+14h2zoePNGvGc7Fjj7Jabu0joxyP9VOLmSG+f7+CQj29U3dnC4XwUN/12eih102+nR1KaYtpC09atv/Pb/SL6ZpEaM/1at9vj3xeRT/vlfC68S5n6u+eSY4jp0/nvFgm7aB7vdk2JhWG6r8r8XZHTY6nRY8Zg7CPtd3Mo4zs2XzkWSTExPZ4d9WaRHNf8Y38M82tF7s4rnV6vuj2vdLqFuTmvdDyOFg9zR9N8OI7bRca7Rdgurw15r0h6PFh5+7w1PJU5dnE8nx51u637xcHG0tss+m6RWKTyLHIw4P1f8Jd3qeVxfBGABymHGYjj1f+9vYuOL1ndvGk/FymPeCxccj8UOe5SER3zfNj++mzS53f+JX18538sce/KqqTP7/xL+vjOv6RvuPO/3yuv7yF+MjqUZO71rRrFvg1xncxo79Z4fFyjcGlVtp/vX6uhvNDUX9c4PZu6eT/0kxq37ofO51IZZFX75zXeHGPPn4BYNFD76749vlSlur2+f9pb73QgTWKAPH8mXh/I+IbOHX9w57bEuRyMe3wC8ojFfvOjqu82auxhVPphlB23+ru1qKyU49JU3jEb7fWtyPE4amL/4HJojuNvdqwGqWV//vn1N7v0j+f9Shmf/2bXx8e/2acSN3+z6+fP+kv9+Fl/OT2Yuv2bfbtXDnl6HB335v3ONe7N+5XTe1R3Y+w80m/N2RX5fJTK56P0uEvWzV1Xj8+l7swNnY/ipldEPvbK6R2qu9Mx5yI3bynPRW7eIZ+L3JwYOhe5OTH0kza5NzH0kza5uZfs6V797sRQOb5BdW+30ONx3JwY+oUi490i9yaGjkXuTwz9ZJzcm9P5hXB+fWl32vjv1nTM+Ypq/6pDKm9OpVRef6qnqZTTQ6q7a45LO25QeXNb6+PpjHirW9IjH06nfcfp9D/4dCRFEUn1cDqnl6g+H2lS49pdnlc0h8PIp3uIuJfZdofIj/alxMdbVp2PIlZS7Hcyvz8KOZ1IXGbWvL0tpPdLpEePt+OeLI/3igzh6zJjuz77tSLsrpb2pXq/0qht2572daOepsm/ocTzrn3wC9HTy1M5F7nZM+ciN3vmJ0Xu9czj/GUSbkV++EzLF+eenlLd3abGrig/9O7xOEa8ZJPGD88O0q8Uqdt8SHmzSOtsWvfDfrtfdu19fMOXfOrjGz7lczyduzuq1Md5R5VH3MJrS6/2zfpZkVvbstTztnX3tmWpj/PmPbe2Zamn96juvnpcTxOJd189rqdnIvdePa7puO/OvVeP6+l9nXuvHp9L3NtS9DhCbu64Uc87Ad7dcaOet4q7t+NGPb1LdXfHjZq+Y7Sm7xit+fPRmr9jtObPR2v+Y0fr3a0Uar75jYrTVgo1f8O+6jW37xgh/fMR8g1bq9fy8d7q5xK3RsjxB/zuq/bnIlxK1FYPFzWlfsNFTfmjpwI00a7P5xfvTY8oY1V/2F7il4qU+KKBSnv9InQ9PyC52bCnh07f07ASV4uq6XA69bwBUFykPTm9vNCr37CLUD09vlKNG4L20Hw4ndOcwM1dhOpPdgK8sw1JPW0EeO+JcT1+qermNiT1tFbs/jYk5zKpcrv2tEB7Pet7GrKtxCm1Ug9D9vzFqlsLxqqUjx8+19MLVvce6x1L3HusV4+7Ad57oFZPmwHee6BWT9+ruvvw+X6vtEOvHEfHrQVjxxo3F4z9rMbj4xr31gPV0xOsHx6Cy3ttenPh2k9q3Fq4Vk8vWN1c2/STGrcWBZzPpcYMS6n55aKA2h5/9HHcWkB3v8abnru5gK6244zTvQV0PxnsNwdI/YM75t7it3re/+/e4refHMitxW+1f7yjWj29ZXV38dvxOO4tfvvphapuF6r11YXqaeu/21e7vX768Op8mdriUw1PfD1Qe/v8Oqj3j6+DTiVuXgcdP1t18zpofPwyYB35G66DbvfKIZPPNzHxm/18NPL62mHI51F4vIvRWIbzxHG4izl+tDcGyBPTe0Wez+7ivqEe76eO6xILS070/Zuy7QnpGPr2TVl8/GLeoB0+mF3PyzVpl/0jr7/ULpVvpNR9Qd3virTPE/58O/QgBvpb1smJDVHT619veXx8/y+nh1Z3fzSPx3G3SY9dGwtXnr1c3hzy6cHz/PSob89D8EGfJ7e3nZPyY7u4kvemMzTF/Zk+H0UfJhRPcyKx5x3jpJZfelRby/ao9tUiB0ntO573Hve/SMyblXcf1WrcS7S2ff72axE5PbcS5etvul3WlF94yvrDN5bzm49qW6yGfc5avX4uIbn8wUWet1cP+re/WYRPAj9nSPKhyPFTADHgq75XYsRT4/3q+5dKpMc2LapyKHKIkeevCIs2949Ijl94ev3gI5LPXNyWfo6v32lPH4XIuUVjRc/I73aKsrhYPu7XQ4mz48ojfqzK9lDk14rkWE7/rHcY56V9PDiONVIq/EzV/t6BpMTnVfZ1/b9WhNcU5pcX3ywi/OrK9mTzF4soN0d9vHs6rJHa31z/XZHTE6ubSXYqcTPJjl/Quptk9Y8erKWyDEfamw1yL4iOJe4F0c1uaaelAOdlo2O74H28uqI6F3n+w0GR/GrtqRw/W3VzAeuxyLcstr7ZIscit1ukf0eL9I9b5PhCDttvjud0zeubkHMRBuvop/eLjjMSt9/qOZXRLh4B2tvL5dbHEqxH0JHbeyUiiHTfR/xXdvO52TM/KXKzZ46rk+/3zKnMzZ45lrjXM+cSt3rmvBtXbFup5fH25mLxWORZ5LCl13mn+Vsvwcvxg1X35t/l8y0B5fMtAeUbNuOT05aA9+bf5fiw6ub8+/1eOWx+eRwdNze/PNa49xK89M8fif6kxr3NL/PnGysfv0Nwdw+9Y5G7+4Cdv4hwc1uzY5G7G/GdT+fmRnzH++67e9fdLzLeLXJz77pzm9zcL+7+d0RePkiQ07tW97Z6O38SJVYRtR9ecPqynlFO35m6+aBYH5/vsKaPjyPgWOLeD5U+Pt9hTR8f77Cmj2/YYe1+r7z+oTqPjnsPivXx+U4rPzmOW6tuNX28VEVT+vwp8fE47j11OzbHzQeZ5xr3HmRqks+bVD9/kHk8jntN+pOv9sQz6p56eRmm51+ou3eG5yL37gzz+RHG3TtDzfkPL3PvBvNc4tYN5k9K3LnBPH9x896nFfTjG0PNn3+iUvPHn6g8lrj5e1s+/0Sllo8/UanlGz5Reb9X2nuD4+5HET6+LdTy+VLqn9S4d1vYPh2i5Rs2Vi/fsCV6+YYd0U/vlt3eKup2jfFmjZsbRX3PjPI37B9+PJu7I2R8PmtwrPEd53J3pI7PR+rp4cfdkXq/xnizxr2Ren4adHukjm+YdNCP5xz09I2qe7tMnZ70PWKoP69j9nf0vlwN6uFH/3nWvO2TXi2zP5dgo9pS+surwdOjsZuP6I4b//Jc/NH00BjH6eR7rwyrnjYfuPvKsH7cHqcVjzneoN43D/vSGscKcUWp+6KJrxVO9z0SS3ySbDsY5a8v2Z9q1MyF3PZS7Nca2k53TiPHG9hPHi932jkuqRN2MKr7ElK5X0Pytq4m7xdSqX05HfnYs8cS9zzb2qdjtB737GQpemsv386RT0f5scKtUX5c1nNzlB9r3B3lp83+bo/y08rgHPti/LCxVU7lfg3hHRCRQ42jU1rj1a3+kNdOOb2fc9MpxxL3nNLHx0653xw/7F36Y3Ocvnf6bAHelt5eqctv1+if19g3lfxa47Q7Dx/2fo7T7Squp/s17MOKV419p4RfqhELFPK8Cn1Z43Ttwgr2J+qbNbjqyKV9XmNbSf+1xmmXXn3EczB97B9y+1JD9fO+Pda42bfnGvf6Vo878+h2NZi+oYa8WYOdAbS392o0Zuaa5Pdq9Hha8nxg8WZ7tFiI/8NL2+/X6G+ey4N3ttOb46PHCzCl1zf7tseWL08c7x5HjI+u7/ZtvHXyxPGm5xoXIKe+Pc7csnNq2X4rf7HGgxr18xq5vJtBvOGQ+5vHUWgPGZ8fxykL8zfkev6GXM/fkOvpG3I9fUOup2/I9fQNuZ6+IddPX7N6xOdo5TH0resPKbFH4RMP10HH69NtR6D++vq0nSakbj5Na8dt/VhC+7SwHg7ktOpUmhdpsn9Hqn+pcbwJ6twE7Q/2vh7Had3p2L5Js39p4GuN88vJlVek9pdofnc2x2aVGO/7d4J/36zHImPbaun1IDne1mmKQZI0H+5y26nMrZnknxyHlu04+uE4zt+zjdn5bTfr1L7Y9zSnbZv2rlvlmk7HcYqAeEoge/d+rXGaSxElirTrezVYJzUf4r6sce6ZGh+DenJ9u0pnp/E6Dm3y8ZRy/3hKuR8DoG8vBI3Hq+Ur7XTPPlI8zH4+m2tvlchxiTly7m/NJxc253+G73ivZ9u20KFJel2lyfh0nuxc4tY8WTtdQ3zDPNmPzZHfb1S+3yDlTdM15kGfrI/XXaMfT/afS9zsmvbHds0PzdEeb3dN26qkl1VOyy3vJdmxwr3HBqczec7ixnLeng6Z3Fr59BnKscQzDfmNeQ6kx3tFmrAt4OvNTX5WhHRv+7TML4yznrkM6eVg3nT6TEjqNW40nzz6e2Wet5rbJvL7pWZ9s0jKbxaRyjc+tu75pSLPU8hxDf/DndHXIu3zB+Tp/KEv8ZEiue8x8CtFSiywkbJvZfmlSOv6cUAfS9wL6P7xS84/aY247ZW672P5tTVOL8LrI5Ya6kPGocjpJp7t37dp1a+3eOfD4L3R/e77186FTT2eN0jp3SLxaFf3hWC/WiR21U/7d1N+N9pP0yuVvZbqqchpaf69n85ziVu/ncdTufvM/Vzk5kP3fnzr++ZD93R676I+YjF8/dE09cuRlE9z6FziVg71h3yeQ6c0bMx6tbzbTn6hiDLH0374YJF8OZnjKvJ768H68bP2d3/uTrNN9hLT8sx2RfO740jf8PW0nvJ3nMxxn6MI55R/+Ehn+XIkp4fVzCZuWdbKLxyGsrdn/+H27GuR8Q3+Py5J1bh2Hj88TEi/VCRadbTtyyu/WqREkfz6o0epHnfUYZ/DfWHqcw77S5Hj98fjlyb/sAvl1yLnFeXxCz76vqLhl9qk07Bjmxv9WqT/5JX4z4v88JrgvlDkS5uci+z7JW43e78v0s7zcEzD5TeLMIX+HE/1zSI1Xjl6xpq8LnJ6e+Hmrlrndi0ad+L7dxN+N2DleE1y670le7ngw0s0/fwSTb7jEk2+4xLtmPN3I7p//mp+L3c79/Wrgv2UrffewzqWuPeqYD+H862Hm/00UXPvVcF+WjZ791XB+71ysFz//NX8Xj9/SS+dbpzv7uF+LnJzD/djkbtv55+P5OYe7mkcX5u+u4f7ucztD2v9rMzNreDPLXNzK/hzkZtbwafx8Q4KR/fc3EHhXOPeDgpdP96Uous3fD/leBw3m/Tctfe2gv/JWL27FfxPytzdCv5nZW5uBX++tJG4Ovph6fkvXR3FjJ7WlyV+cukbh/G8R333+rnGyxpp/7rV+xfhhyI/uUWKa9/RD5+57e3zCaz2+QTW529GHUvcnAM7N2iMj2fb6qFBP34mcCyRbLu5NTr0cRinxyIaj1mSlvFmkS48LpV3j2Tw1e/HI71X5O7MxPlIWLSVWj+cznmP3Zt34ccid+/Cu3zDXfjxGdbNu/Bzu7J0o6f0bpPcTOdzk9xM59udc0rn41479yaPxzd8pbqPb/hKdTp9lr1JXPk2TfuTvXy/yHNmOTaYKrm+WUSig7v88IjhSwePj1de/eQ4Yh/1Lj+sd/zxOMbj430AziVu/XKOx8f7AKR8/ERu7LnTVdKha/vHU2jHEvem0I6XZnen0M4Xifem0MbjO55yHLe3vzeFNs4PsW5NoY3TM6x7U2jHEvem0Eb6/P2Acdpq794U2jg9er47hXa/Vw5TaMfRcW8KbaTx+RTa8TPdd6fQjkXuTqGJfsMU2vFI7k6hnT47/gtTaMcy96fQflLm7hSa6DdMoR2L3J1Ck493zDy65+4Umtx9uvh6Cm2c9v+7N4U2Svl8Cu14HHebVL9hCu08Vm9PoZ3L3J5C+0mZu1Nox0ube1No56ujO1NoKZVP72rG8SvTN+9qxuk51u27muPPcI5XdMszsrer1voLRVosIyvjh5fJvhb5fOfMlD5eX38uce/y+Xgmdy+fz81x8/JZvmORYDluIb4tsE/tde+W45Hw0tGo+91z+pUidUvo8maR1tlP64e3H742rH6DgeU71qPX88dd+dyVtvS6i08vQHEkzwu+Q5vo4xva5Pxa+d11fqcvM2hsUJhV9TBij59WiV+brK2+LDK0fkebfMf01XErOmHv7CenV99WS8dJztsX0sf9I6vyru0PH0X+8h7U6Z393OjjVl/ftrXPP1kx2sefrDiWuHlT3z7/ZMVoH3+yYrRv+GTF/V55fSHwk9ERU5O5HW4pTjVKauwWNtq7NR4f12jCsnR9PdJ7ujlBIe+1adlWPj8v896socz29tc1vuF7VeMbvld1PpcaP7xlf0Tyu+Nof/RxYLrn07DPa7zpuedMfosa/fVYP67eUjZabvmQQufBfnOApD+4Y1rCuIcQGsdPorbt/lteN8j5QAb7hR1GyOlLVTcnWEb/hgmW0T6eYPnJpVBRLoXk5cOvx/EFrG2IzCr9rSo3Hzwdv0V47/HG8zjqx5dCa2r4s2uhc417F0PPGu3jq6G5lfunl0PrY8OfXg/9Qt8cZkaOg+TeU470OD19uvuY47R78+3HHMcidx9ztPYNjzmOR3L3MUfr3/KY4yd3Z3efTxxP6e7ziWORu88nmn6e9fL584ljjXvPJ9Ij109/P5815PMf0POR3G3V9g2PKM7D9fYjinOZ248oflLm7iOKn0zH8Q6ivt6O5Hnu+Vil9K3Ky8maenqOZFm+OulRXq+NTfX4gdK4qG8tv14Pmh6nt4hF2QFA9zWUXx4hnabj9rcHtzcq5yZY94u0WBD6nD96vC7yOG4o+C1Vnrc6D7q4v1ulNZZzjkOzPOppEis2jGv7Q49fqrF9sFD6mzWewRVz8/smi/9DlfP84p3lnEmPL+8UbrweddtpbXwd+CcPxq412/K4Wn6lVeOxychv94zyBST5vHdPNY7mK/FY7Onl9GaR3NkO+HEa75I/HyHHIoldWp5XW/3NQ0lJ2Vi0y7tV+HLYE98+Ftm+ErM9BvrVKsrtynaF/6tnxGOtff/p/6HK+DzYTjXuBtvxfeLbwaZ/+LAt8bA+FWnvNsrNXDrWuJlLNzvnVOP4xP/eqpLzooF7q0o+fz0sffx62E82a+Pu/Afv/tKOb8q2cTrKm0U6Qb+vKfnFbeNyTEk/8uvTaaftdO/uPXcscu/jx+cStz5+/JMStz5+fOyXFnNAcxbmzc79oUh9t0imSDkNs56PTy3uvAdxrnHrBYRnjfrH1ri7B9axUfV/3NbzF3smJhtzG++myH4kbxfp8SjoiW8XiauIY5Hx8Y/M+Pg35iebRye+UZvf3H86bsOf+Gqx0XEv7lstcd7N+9Zr0Kcd0luK+Yj2w0Zgv7DLeo8FetJLerMGH43o483d3rtwHO/uOt/jOcWz3Lu7zieeuua322NQ43W/HHfyl3iEXKWVb6jx3tcAqsYlclWpb9aItYrPadbXbXqaRH/O4PWYhEiHGbzjnpVVYqQ+T6y+nBz9yZHcm0tMp3d+7s0ltvH5VOKxxt05wHR8F+tbqtyeSTxXuTuTmFL7+Ib7WOPmDfexxu0bbpv1//SG+9ywg5mMPdS+HsppD5L7Js7lcxP/5Ehumjh//EBgyOcmPta4bb/c/+gq902cv+NxwHE5+F0Tl88fB5yX6t82cfmGxwHnhr1p4uP3gR5RQx759VVWOu4eK7mzAf1+zfi7Njm9BtWiZZ8PLPurIueziY/IyT4t8vuzOe0JePtsTg8nvuNsUiyyfeJ7V41SYvnFl139f6FG5jiyfEMNTW/W6Hyh4PF4s0aLO4Lc323TeCQh5eCZc41CjVpPvvv8Sdy5xr0Z77vBeqhx/Nm7+SDu/PN78znc+QXku9Es8g3P4X5S5eZzuHOVu8/hzlXuPof7SZWbz+F+ckY3n8MdH6ffvaI41bh7RXF+rH/3ikL/8GF79zncuVFuptKxxs1Uutk5xxrH+76b53KscfNcbt5/HmocZwduJux5luJuwrbvGKrtWxK2fUvCtm9J2PYtCdu+JWHbtyRs/4aE7d+QsP1bErb/4cP2dsL2b0jY/g0J2z9O2PPntmNJ2w/vI/3aJ7v3Gv29Gv3B60jpzc+g95hAKr2++QnzHi8zP3G8exzxjlfXdz9hHpM2Tzwcx/FTfdEvzyFR36tR4tuyz1+t8m6NBzXq5zXym8eRB7+eub95HIX2kPH5cejrsS7yed+KfN63P6lxq29v18hvHsfNvj0fx72+vX0ch749ra9/zl3HleK+/07++i2onD5fxHKucW8BSk71j61x84u/xxeY+OJoaY9Tm57mWe98C/J4GJVVMPs1zP9wGOPzCdJ8eo51c4L0eDbC5tPPCcaXZ3OuEROTWfR1i2g/bizIu38ij/eK3FuOdy5xazneT0rcWY5XT5/nu7WY5ljh1mKa8vGCnvLxgh45PM8YQ+IKe/T08snmuQZX2GPfGf1LDT3vWPlgB4PHo8t7ZW6Oz2OJe+PzXOLO+DxtojRyLCwaeVtY9PzB+oUahVVr21H8rsb4fHyca9wcH/V7xkf9fHzUz8dHfW98/O/n//Onf/nL3//pr//6L3/6j7/869/+/fnv/nuW+vtf/vTPf/3z9f/+3//8279s/+t//P//zf+Xf/77X/7617/8v3/6t7//67/8+f/859//PCvN/+23x/V//teYn20Zz4ua//0Pv5X5/z9/Ap7/fy7P/z+tv6D9H0Zq9h+S/Y1c59/Q//3f8xD/Pw==","expression_width":{"Bounded":{"width":4}}}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"SecretSanta::advance_state_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SecretSanta::advance_state_parameters","fields":[]}}]},{"kind":"struct","path":"SecretSanta::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SecretSanta::constructor_parameters","fields":[{"name":"admin","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"SecretSanta::disclose_receiver_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SecretSanta::disclose_receiver_parameters","fields":[{"name":"sender_index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"receiver_nullifier","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"SecretSanta::get_admin_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SecretSanta::get_admin_parameters","fields":[]}},{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"SecretSanta::get_assignment_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SecretSanta::get_assignment_parameters","fields":[{"name":"sender_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"SecretSanta::get_event_id_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SecretSanta::get_event_id_parameters","fields":[]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"SecretSanta::get_game_state_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SecretSanta::get_game_state_parameters","fields":[]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":8}}]},{"kind":"struct","path":"SecretSanta::get_participant_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SecretSanta::get_participant_parameters","fields":[{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"SecretSanta::get_participant_count_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SecretSanta::get_participant_count_parameters","fields":[]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":32}}]},{"kind":"struct","path":"SecretSanta::get_sender_count_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SecretSanta::get_sender_count_parameters","fields":[]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":32}}]},{"kind":"struct","path":"SecretSanta::get_sender_nullifier_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SecretSanta::get_sender_nullifier_parameters","fields":[{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"SecretSanta::get_sender_randomness_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SecretSanta::get_sender_randomness_parameters","fields":[{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"return_type","type":{"kind":"field"}}]},{"kind":"struct","path":"SecretSanta::process_message_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SecretSanta::process_message_parameters","fields":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}}]},{"kind":"struct","path":"SecretSanta::register_participants_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SecretSanta::register_participants_parameters","fields":[{"name":"p0","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"p1","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"p2","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"p3","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"p4","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"p5","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"p6","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"p7","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"count","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]},{"kind":"struct","path":"SecretSanta::submit_randomness_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SecretSanta::submit_randomness_parameters","fields":[{"name":"nullifier","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"SecretSanta::sync_private_state_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SecretSanta::sync_private_state_parameters","fields":[]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"SecretSanta"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"game_state","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"event_id","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"participant_count","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"participants","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"sender_count","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"sender_nullifiers","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"sender_randomness","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}]}},{"name":"assignments","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000a"}}]}},{"name":"spent_nullifiers","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000b"}}]}},{"name":"has_disclosed","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000c"}}]}}]}}]}]}},"file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n","path":"std/array/mod.nr"},"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"50":{"source":"use dep::aztec::macros::aztec;\n\n/// ZK Secret Santa - Aztec Native Implementation (Simplified MVP)\n#[aztec]\npub contract SecretSanta {\n    use dep::aztec::{\n        macros::{\n            storage::storage,\n            functions::{external, initializer, view},\n        },\n        protocol_types::{\n            address::AztecAddress,\n            hash::poseidon2_hash,\n            traits::ToField,\n        },\n        state_vars::{Map, PublicMutable, PublicImmutable},\n    };\n\n    // Game states\n    global STATE_REGISTRATION: u8 = 0;\n    global STATE_SUBMISSION: u8 = 1;\n    global STATE_DISCLOSURE: u8 = 2;\n    global STATE_COMPLETE: u8 = 3;\n\n    global MAX_PARTICIPANTS: u32 = 8;\n\n    #[storage]\n    struct Storage<Context> {\n        admin: PublicMutable<AztecAddress, Context>,\n        game_state: PublicMutable<u8, Context>,\n        event_id: PublicImmutable<Field, Context>,\n        participant_count: PublicMutable<u32, Context>,\n        participants: Map<u32, PublicMutable<AztecAddress, Context>, Context>,\n        sender_count: PublicMutable<u32, Context>,\n        sender_nullifiers: Map<u32, PublicMutable<Field, Context>, Context>,\n        sender_randomness: Map<u32, PublicMutable<Field, Context>, Context>,\n        assignments: Map<u32, PublicMutable<AztecAddress, Context>, Context>,\n        spent_nullifiers: Map<Field, PublicMutable<bool, Context>, Context>,\n        has_disclosed: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n    }\n\n    #[external(\"public\")]\n    #[initializer]\n    fn constructor(admin: AztecAddress) {\n        storage.admin.write(admin);\n        storage.game_state.write(STATE_REGISTRATION);\n        storage.participant_count.write(0);\n        storage.sender_count.write(0);\n        let event_id = poseidon2_hash([context.this_address().to_field(), 1]);\n        storage.event_id.initialize(event_id);\n    }\n\n    #[external(\"public\")]\n    fn register_participants(\n        p0: AztecAddress,\n        p1: AztecAddress,\n        p2: AztecAddress,\n        p3: AztecAddress,\n        p4: AztecAddress,\n        p5: AztecAddress,\n        p6: AztecAddress,\n        p7: AztecAddress,\n        count: u32\n    ) {\n        assert(storage.admin.read().eq(context.msg_sender().unwrap()), \"Only admin\");\n        assert(storage.game_state.read() == STATE_REGISTRATION, \"Wrong state\");\n        assert(count >= 2, \"Need at least 2\");\n        assert(count <= MAX_PARTICIPANTS, \"Too many\");\n\n        let participants = [p0, p1, p2, p3, p4, p5, p6, p7];\n        for i in 0..MAX_PARTICIPANTS {\n            if i < count {\n                storage.participants.at(i).write(participants[i]);\n            }\n        }\n        storage.participant_count.write(count);\n    }\n\n    #[external(\"public\")]\n    fn advance_state() {\n        assert(storage.admin.read().eq(context.msg_sender().unwrap()), \"Only admin\");\n        let current = storage.game_state.read();\n        assert(current < STATE_COMPLETE, \"Already complete\");\n        storage.game_state.write(current + 1);\n    }\n\n    /// Submit randomness with a nullifier derived off-chain\n    /// In production, this would be done via private function\n    #[external(\"public\")]\n    fn submit_randomness(nullifier: Field, randomness: Field) {\n        assert(storage.game_state.read() == STATE_SUBMISSION, \"Wrong state\");\n        assert(!storage.spent_nullifiers.at(nullifier).read(), \"Nullifier spent\");\n\n        let index = storage.sender_count.read();\n        storage.sender_nullifiers.at(index).write(nullifier);\n        storage.sender_randomness.at(index).write(randomness);\n        storage.sender_count.write(index + 1);\n        storage.spent_nullifiers.at(nullifier).write(true);\n    }\n\n    /// Disclose as receiver - proves off-chain that receiver_nullifier != sender_nullifier\n    #[external(\"public\")]\n    fn disclose_receiver(sender_index: u32, receiver_nullifier: Field) {\n        let receiver = context.msg_sender().unwrap();\n        assert(storage.game_state.read() == STATE_DISCLOSURE, \"Wrong state\");\n        assert(!storage.has_disclosed.at(receiver).read(), \"Already disclosed\");\n        assert(sender_index < storage.sender_count.read(), \"Invalid index\");\n\n        let sender_nullifier = storage.sender_nullifiers.at(sender_index).read();\n        // In production, this check happens in ZK proof\n        // Here we trust the caller provides a valid receiver_nullifier\n        assert(receiver_nullifier != sender_nullifier, \"Cannot choose yourself\");\n\n        assert(storage.assignments.at(sender_index).read().is_zero(), \"Already assigned\");\n\n        storage.assignments.at(sender_index).write(receiver);\n        storage.has_disclosed.at(receiver).write(true);\n    }\n\n    // View functions\n    #[external(\"public\")]\n    #[view]\n    fn get_admin() -> AztecAddress {\n        storage.admin.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_game_state() -> u8 {\n        storage.game_state.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_event_id() -> Field {\n        storage.event_id.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_participant_count() -> u32 {\n        storage.participant_count.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_participant(index: u32) -> AztecAddress {\n        storage.participants.at(index).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_sender_count() -> u32 {\n        storage.sender_count.read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_sender_nullifier(index: u32) -> Field {\n        storage.sender_nullifiers.at(index).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_sender_randomness(index: u32) -> Field {\n        storage.sender_randomness.at(index).read()\n    }\n\n    #[external(\"public\")]\n    #[view]\n    fn get_assignment(sender_index: u32) -> AztecAddress {\n        storage.assignments.at(sender_index).read()\n    }\n}\n","path":"/home/finarfin/workspace/zorzal/zk-ss/contracts/secret_santa/src/main.nr"},"59":{"source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/capsules/mod.nr"},"68":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"70":{"source":"use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/utility_context.nr"},"73":{"source":"use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/event/event_selector.nr"},"75":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args_array(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    dep::std::println(hash);\n    let hash_check = hash_calldata(input.as_slice());\n    assert(hash == hash_check);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/hash.nr"},"96":{"source":"use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[external(\"utility\")] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/aztec.nr"},"97":{"source":"use super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[external(\"public\")]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr"},"102":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr"},"105":{"source":"use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY,\n        call_interface_stubs::{\n            register_private_fn_stub, register_public_fn_stub, register_utility_fn_stub,\n        },\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_contract_library_method, is_fn_external,\n        is_fn_initializer, is_fn_internal, is_fn_test, is_fn_view, modify_fn_body,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse dep::protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    register_private_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let context_creation = quote {\n        $args_serialization\n        let args_hash = dep::aztec::hash::hash_args_array($serialized_args_name);\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n    };\n\n    let function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {function_name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message =\n            f\"Function {function_name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    register_public_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    let name = f.name();\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let name = f.name();\n        let assertion_message =\n            f\"Function {name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    register_utility_fn_stub(f);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender().unwrap())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f) & !is_fn_contract_library_method(f) & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr"},"108":{"source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/storage.nr"},"110":{"source":"use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr"},"111":{"source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            compute_note_hash_for_nullification(retrieved_note, STORAGE_SLOT),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr"},"112":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr"},"113":{"source":"use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr"},"114":{"source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr"},"115":{"source":"use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    process_message_plaintext(\n        contract_address,\n        compute_note_hash_and_nullifier,\n        AES128::decrypt(message_ciphertext, message_context.recipient),\n        message_context,\n    );\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr"},"116":{"source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\n// 479 / 32 = 15\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/encoding.nr"},"117":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret_using_aztec_address.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient).unwrap();\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, MESSAGE_PLAINTEXT_LEN> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        // TODO(#17158): handle invalid ephemeral keys when decrypting to prevent DoS vectors\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk.unwrap());\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret.unwrap());\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr"},"134":{"source":"pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr"},"154":{"source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr"},"156":{"source":"use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"158":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"166":{"source":"use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr"},"171":{"source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr"},"173":{"source":"/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 3;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version '3', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/version.nr"},"177":{"source":"use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"185":{"source":"use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::HasStorageSlot,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> HasStorageSlot<M + 1> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    /// Initializes a new PublicImmutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`PrivateContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the anchor block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   anchor block header.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_anchor_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr"},"187":{"source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> HasStorageSlot<M> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    /// Initializes a new PublicMutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`UtilityContext`. The Context determines\n    ///               which methods of this struct will be made available to the calling\n    ///               smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"207":{"source":"/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/array/append.nr"},"210":{"source":"/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"211":{"source":"use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr"},"213":{"source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr"},"214":{"source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr"},"217":{"source":"use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"221":{"source":"use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.anchor_block_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr"},"228":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/finarfin/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"250":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"291":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"306":{"source":"// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"316":{"source":"mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"329":{"source":"use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"330":{"source":"/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr"},"332":{"source":"use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"344":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"360":{"source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"362":{"source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"363":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"381":{"source":"global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"385":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/finarfin/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"}}}